/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef api_TYPES_H
#define api_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct CommitItemChangeType {
  enum type {
    ADDED = 0,
    DELETED = 1,
    REPLACED = 2,
    UNKNOWN = 3,
    UPDATED = 4
  };
};

extern const std::map<int, const char*> _CommitItemChangeType_VALUES_TO_NAMES;

struct HawkPluginCategory {
  enum type {
    BACKEND = 0,
    GRAPH_CHANGE_LISTENER = 1,
    INDEX_FACTORY = 2,
    METAMODEL_INTROSPECTOR = 3,
    METAMODEL_RESOURCE_FACTORY = 4,
    METAMODEL_UPDATER = 5,
    MODEL_RESOURCE_FACTORY = 6,
    MODEL_UPDATER = 7,
    QUERY_ENGINE = 8,
    VCS_MANAGER = 9
  };
};

extern const std::map<int, const char*> _HawkPluginCategory_VALUES_TO_NAMES;

struct HawkState {
  enum type {
    RUNNING = 0,
    STOPPED = 1,
    UPDATING = 2
  };
};

extern const std::map<int, const char*> _HawkState_VALUES_TO_NAMES;

struct SubscriptionDurability {
  enum type {
    DEFAULT = 0,
    DURABLE = 1,
    TEMPORARY = 2
  };
};

extern const std::map<int, const char*> _SubscriptionDurability_VALUES_TO_NAMES;

class CommitItem;

class Credentials;

class DerivedAttributeSpec;

class FailedQuery;

class File;

class HawkFactoryNotFound;

class HawkInstance;

class HawkInstanceNotFound;

class HawkInstanceNotRunning;

class HawkMetamodelNotFound;

class HawkPlugin;

class HawkStateEvent;

class HawkSynchronizationEndEvent;

class HawkSynchronizationStartEvent;

class HawkTypeNotFound;

class IndexedAttributeSpec;

class InvalidDerivedAttributeSpec;

class InvalidIndexedAttributeSpec;

class InvalidMetamodel;

class InvalidPollingConfiguration;

class InvalidQuery;

class InvalidTransformation;

class MetamodelParserDetails;

class MixedReference;

class ModelSpec;

class Repository;

class Slot;

class SlotMetadata;

class SlotValue;

class Subscription;

class UnknownQueryLanguage;

class UnknownRepositoryType;

class UserExists;

class UserNotFound;

class UserProfile;

class VCSAuthenticationFailed;

class Value;

class AttributeSlot;

class HawkAttributeRemovalEvent;

class HawkAttributeUpdateEvent;

class HawkFileAdditionEvent;

class HawkFileRemovalEvent;

class HawkModelElementAdditionEvent;

class HawkModelElementRemovalEvent;

class HawkReferenceAdditionEvent;

class HawkReferenceRemovalEvent;

class InvalidModelSpec;

class ModelElementType;

class ReferenceSlot;

class HawkChangeEvent;

class HawkQueryOptions;

class ModelElement;

class ContainerSlot;

class QueryResult;

class QueryReport;


class CommitItem {
 public:

  CommitItem(const CommitItem&);
  CommitItem& operator=(const CommitItem&);
  CommitItem() : repoURL(), revision(), path(), type((CommitItemChangeType::type)0) {
  }

  virtual ~CommitItem() throw();
  std::string repoURL;
  std::string revision;
  std::string path;
  CommitItemChangeType::type type;

  void __set_repoURL(const std::string& val);

  void __set_revision(const std::string& val);

  void __set_path(const std::string& val);

  void __set_type(const CommitItemChangeType::type val);

  bool operator == (const CommitItem & rhs) const
  {
    if (!(repoURL == rhs.repoURL))
      return false;
    if (!(revision == rhs.revision))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const CommitItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommitItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CommitItem &a, CommitItem &b);

inline std::ostream& operator<<(std::ostream& out, const CommitItem& obj)
{
  obj.printTo(out);
  return out;
}


class Credentials {
 public:

  Credentials(const Credentials&);
  Credentials& operator=(const Credentials&);
  Credentials() : username(), password() {
  }

  virtual ~Credentials() throw();
  std::string username;
  std::string password;

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  bool operator == (const Credentials & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const Credentials &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Credentials & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Credentials &a, Credentials &b);

inline std::ostream& operator<<(std::ostream& out, const Credentials& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DerivedAttributeSpec__isset {
  _DerivedAttributeSpec__isset() : attributeType(false), isMany(false), isOrdered(false), isUnique(false), derivationLanguage(false), derivationLogic(false) {}
  bool attributeType :1;
  bool isMany :1;
  bool isOrdered :1;
  bool isUnique :1;
  bool derivationLanguage :1;
  bool derivationLogic :1;
} _DerivedAttributeSpec__isset;

class DerivedAttributeSpec {
 public:

  DerivedAttributeSpec(const DerivedAttributeSpec&);
  DerivedAttributeSpec& operator=(const DerivedAttributeSpec&);
  DerivedAttributeSpec() : metamodelUri(), typeName(), attributeName(), attributeType(), isMany(0), isOrdered(0), isUnique(0), derivationLanguage(), derivationLogic() {
  }

  virtual ~DerivedAttributeSpec() throw();
  std::string metamodelUri;
  std::string typeName;
  std::string attributeName;
  std::string attributeType;
  bool isMany;
  bool isOrdered;
  bool isUnique;
  std::string derivationLanguage;
  std::string derivationLogic;

  _DerivedAttributeSpec__isset __isset;

  void __set_metamodelUri(const std::string& val);

  void __set_typeName(const std::string& val);

  void __set_attributeName(const std::string& val);

  void __set_attributeType(const std::string& val);

  void __set_isMany(const bool val);

  void __set_isOrdered(const bool val);

  void __set_isUnique(const bool val);

  void __set_derivationLanguage(const std::string& val);

  void __set_derivationLogic(const std::string& val);

  bool operator == (const DerivedAttributeSpec & rhs) const
  {
    if (!(metamodelUri == rhs.metamodelUri))
      return false;
    if (!(typeName == rhs.typeName))
      return false;
    if (!(attributeName == rhs.attributeName))
      return false;
    if (__isset.attributeType != rhs.__isset.attributeType)
      return false;
    else if (__isset.attributeType && !(attributeType == rhs.attributeType))
      return false;
    if (__isset.isMany != rhs.__isset.isMany)
      return false;
    else if (__isset.isMany && !(isMany == rhs.isMany))
      return false;
    if (__isset.isOrdered != rhs.__isset.isOrdered)
      return false;
    else if (__isset.isOrdered && !(isOrdered == rhs.isOrdered))
      return false;
    if (__isset.isUnique != rhs.__isset.isUnique)
      return false;
    else if (__isset.isUnique && !(isUnique == rhs.isUnique))
      return false;
    if (__isset.derivationLanguage != rhs.__isset.derivationLanguage)
      return false;
    else if (__isset.derivationLanguage && !(derivationLanguage == rhs.derivationLanguage))
      return false;
    if (__isset.derivationLogic != rhs.__isset.derivationLogic)
      return false;
    else if (__isset.derivationLogic && !(derivationLogic == rhs.derivationLogic))
      return false;
    return true;
  }
  bool operator != (const DerivedAttributeSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DerivedAttributeSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DerivedAttributeSpec &a, DerivedAttributeSpec &b);

inline std::ostream& operator<<(std::ostream& out, const DerivedAttributeSpec& obj)
{
  obj.printTo(out);
  return out;
}


class FailedQuery : public ::apache::thrift::TException {
 public:

  FailedQuery(const FailedQuery&);
  FailedQuery& operator=(const FailedQuery&);
  FailedQuery() : reason() {
  }

  virtual ~FailedQuery() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const FailedQuery & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const FailedQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FailedQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(FailedQuery &a, FailedQuery &b);

inline std::ostream& operator<<(std::ostream& out, const FailedQuery& obj)
{
  obj.printTo(out);
  return out;
}


class File {
 public:

  File(const File&);
  File& operator=(const File&);
  File() : name(), contents() {
  }

  virtual ~File() throw();
  std::string name;
  std::string contents;

  void __set_name(const std::string& val);

  void __set_contents(const std::string& val);

  bool operator == (const File & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(contents == rhs.contents))
      return false;
    return true;
  }
  bool operator != (const File &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const File & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(File &a, File &b);

inline std::ostream& operator<<(std::ostream& out, const File& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkFactoryNotFound__isset {
  _HawkFactoryNotFound__isset() : factoryName(false) {}
  bool factoryName :1;
} _HawkFactoryNotFound__isset;

class HawkFactoryNotFound : public ::apache::thrift::TException {
 public:

  HawkFactoryNotFound(const HawkFactoryNotFound&);
  HawkFactoryNotFound& operator=(const HawkFactoryNotFound&);
  HawkFactoryNotFound() : factoryName() {
  }

  virtual ~HawkFactoryNotFound() throw();
  std::string factoryName;

  _HawkFactoryNotFound__isset __isset;

  void __set_factoryName(const std::string& val);

  bool operator == (const HawkFactoryNotFound & rhs) const
  {
    if (__isset.factoryName != rhs.__isset.factoryName)
      return false;
    else if (__isset.factoryName && !(factoryName == rhs.factoryName))
      return false;
    return true;
  }
  bool operator != (const HawkFactoryNotFound &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkFactoryNotFound & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(HawkFactoryNotFound &a, HawkFactoryNotFound &b);

inline std::ostream& operator<<(std::ostream& out, const HawkFactoryNotFound& obj)
{
  obj.printTo(out);
  return out;
}


class HawkInstance {
 public:

  HawkInstance(const HawkInstance&);
  HawkInstance& operator=(const HawkInstance&);
  HawkInstance() : name(), state((HawkState::type)0), message() {
  }

  virtual ~HawkInstance() throw();
  std::string name;
  HawkState::type state;
  std::string message;

  void __set_name(const std::string& val);

  void __set_state(const HawkState::type val);

  void __set_message(const std::string& val);

  bool operator == (const HawkInstance & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const HawkInstance &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkInstance & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkInstance &a, HawkInstance &b);

inline std::ostream& operator<<(std::ostream& out, const HawkInstance& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkInstanceNotFound__isset {
  _HawkInstanceNotFound__isset() : instanceName(false) {}
  bool instanceName :1;
} _HawkInstanceNotFound__isset;

class HawkInstanceNotFound : public ::apache::thrift::TException {
 public:

  HawkInstanceNotFound(const HawkInstanceNotFound&);
  HawkInstanceNotFound& operator=(const HawkInstanceNotFound&);
  HawkInstanceNotFound() : instanceName() {
  }

  virtual ~HawkInstanceNotFound() throw();
  std::string instanceName;

  _HawkInstanceNotFound__isset __isset;

  void __set_instanceName(const std::string& val);

  bool operator == (const HawkInstanceNotFound & rhs) const
  {
    if (__isset.instanceName != rhs.__isset.instanceName)
      return false;
    else if (__isset.instanceName && !(instanceName == rhs.instanceName))
      return false;
    return true;
  }
  bool operator != (const HawkInstanceNotFound &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkInstanceNotFound & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(HawkInstanceNotFound &a, HawkInstanceNotFound &b);

inline std::ostream& operator<<(std::ostream& out, const HawkInstanceNotFound& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkInstanceNotRunning__isset {
  _HawkInstanceNotRunning__isset() : instanceName(false) {}
  bool instanceName :1;
} _HawkInstanceNotRunning__isset;

class HawkInstanceNotRunning : public ::apache::thrift::TException {
 public:

  HawkInstanceNotRunning(const HawkInstanceNotRunning&);
  HawkInstanceNotRunning& operator=(const HawkInstanceNotRunning&);
  HawkInstanceNotRunning() : instanceName() {
  }

  virtual ~HawkInstanceNotRunning() throw();
  std::string instanceName;

  _HawkInstanceNotRunning__isset __isset;

  void __set_instanceName(const std::string& val);

  bool operator == (const HawkInstanceNotRunning & rhs) const
  {
    if (__isset.instanceName != rhs.__isset.instanceName)
      return false;
    else if (__isset.instanceName && !(instanceName == rhs.instanceName))
      return false;
    return true;
  }
  bool operator != (const HawkInstanceNotRunning &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkInstanceNotRunning & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(HawkInstanceNotRunning &a, HawkInstanceNotRunning &b);

inline std::ostream& operator<<(std::ostream& out, const HawkInstanceNotRunning& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkMetamodelNotFound__isset {
  _HawkMetamodelNotFound__isset() : metamodelURI(false) {}
  bool metamodelURI :1;
} _HawkMetamodelNotFound__isset;

class HawkMetamodelNotFound : public ::apache::thrift::TException {
 public:

  HawkMetamodelNotFound(const HawkMetamodelNotFound&);
  HawkMetamodelNotFound& operator=(const HawkMetamodelNotFound&);
  HawkMetamodelNotFound() : metamodelURI() {
  }

  virtual ~HawkMetamodelNotFound() throw();
  std::string metamodelURI;

  _HawkMetamodelNotFound__isset __isset;

  void __set_metamodelURI(const std::string& val);

  bool operator == (const HawkMetamodelNotFound & rhs) const
  {
    if (__isset.metamodelURI != rhs.__isset.metamodelURI)
      return false;
    else if (__isset.metamodelURI && !(metamodelURI == rhs.metamodelURI))
      return false;
    return true;
  }
  bool operator != (const HawkMetamodelNotFound &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkMetamodelNotFound & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(HawkMetamodelNotFound &a, HawkMetamodelNotFound &b);

inline std::ostream& operator<<(std::ostream& out, const HawkMetamodelNotFound& obj)
{
  obj.printTo(out);
  return out;
}


class HawkPlugin {
 public:

  HawkPlugin(const HawkPlugin&);
  HawkPlugin& operator=(const HawkPlugin&);
  HawkPlugin() : name(), description(), category((HawkPluginCategory::type)0) {
  }

  virtual ~HawkPlugin() throw();
  std::string name;
  std::string description;
  HawkPluginCategory::type category;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_category(const HawkPluginCategory::type val);

  bool operator == (const HawkPlugin & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(category == rhs.category))
      return false;
    return true;
  }
  bool operator != (const HawkPlugin &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkPlugin & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkPlugin &a, HawkPlugin &b);

inline std::ostream& operator<<(std::ostream& out, const HawkPlugin& obj)
{
  obj.printTo(out);
  return out;
}


class HawkStateEvent {
 public:

  HawkStateEvent(const HawkStateEvent&);
  HawkStateEvent& operator=(const HawkStateEvent&);
  HawkStateEvent() : timestamp(0), state((HawkState::type)0), message() {
  }

  virtual ~HawkStateEvent() throw();
  int64_t timestamp;
  HawkState::type state;
  std::string message;

  void __set_timestamp(const int64_t val);

  void __set_state(const HawkState::type val);

  void __set_message(const std::string& val);

  bool operator == (const HawkStateEvent & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const HawkStateEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkStateEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkStateEvent &a, HawkStateEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkStateEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkSynchronizationEndEvent {
 public:

  HawkSynchronizationEndEvent(const HawkSynchronizationEndEvent&);
  HawkSynchronizationEndEvent& operator=(const HawkSynchronizationEndEvent&);
  HawkSynchronizationEndEvent() : timestampNanos(0) {
  }

  virtual ~HawkSynchronizationEndEvent() throw();
  int64_t timestampNanos;

  void __set_timestampNanos(const int64_t val);

  bool operator == (const HawkSynchronizationEndEvent & rhs) const
  {
    if (!(timestampNanos == rhs.timestampNanos))
      return false;
    return true;
  }
  bool operator != (const HawkSynchronizationEndEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkSynchronizationEndEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkSynchronizationEndEvent &a, HawkSynchronizationEndEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkSynchronizationEndEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkSynchronizationStartEvent {
 public:

  HawkSynchronizationStartEvent(const HawkSynchronizationStartEvent&);
  HawkSynchronizationStartEvent& operator=(const HawkSynchronizationStartEvent&);
  HawkSynchronizationStartEvent() : timestampNanos(0) {
  }

  virtual ~HawkSynchronizationStartEvent() throw();
  int64_t timestampNanos;

  void __set_timestampNanos(const int64_t val);

  bool operator == (const HawkSynchronizationStartEvent & rhs) const
  {
    if (!(timestampNanos == rhs.timestampNanos))
      return false;
    return true;
  }
  bool operator != (const HawkSynchronizationStartEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkSynchronizationStartEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkSynchronizationStartEvent &a, HawkSynchronizationStartEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkSynchronizationStartEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkTypeNotFound__isset {
  _HawkTypeNotFound__isset() : typeName(false) {}
  bool typeName :1;
} _HawkTypeNotFound__isset;

class HawkTypeNotFound : public ::apache::thrift::TException {
 public:

  HawkTypeNotFound(const HawkTypeNotFound&);
  HawkTypeNotFound& operator=(const HawkTypeNotFound&);
  HawkTypeNotFound() : typeName() {
  }

  virtual ~HawkTypeNotFound() throw();
  std::string typeName;

  _HawkTypeNotFound__isset __isset;

  void __set_typeName(const std::string& val);

  bool operator == (const HawkTypeNotFound & rhs) const
  {
    if (__isset.typeName != rhs.__isset.typeName)
      return false;
    else if (__isset.typeName && !(typeName == rhs.typeName))
      return false;
    return true;
  }
  bool operator != (const HawkTypeNotFound &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkTypeNotFound & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(HawkTypeNotFound &a, HawkTypeNotFound &b);

inline std::ostream& operator<<(std::ostream& out, const HawkTypeNotFound& obj)
{
  obj.printTo(out);
  return out;
}


class IndexedAttributeSpec {
 public:

  IndexedAttributeSpec(const IndexedAttributeSpec&);
  IndexedAttributeSpec& operator=(const IndexedAttributeSpec&);
  IndexedAttributeSpec() : metamodelUri(), typeName(), attributeName() {
  }

  virtual ~IndexedAttributeSpec() throw();
  std::string metamodelUri;
  std::string typeName;
  std::string attributeName;

  void __set_metamodelUri(const std::string& val);

  void __set_typeName(const std::string& val);

  void __set_attributeName(const std::string& val);

  bool operator == (const IndexedAttributeSpec & rhs) const
  {
    if (!(metamodelUri == rhs.metamodelUri))
      return false;
    if (!(typeName == rhs.typeName))
      return false;
    if (!(attributeName == rhs.attributeName))
      return false;
    return true;
  }
  bool operator != (const IndexedAttributeSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IndexedAttributeSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IndexedAttributeSpec &a, IndexedAttributeSpec &b);

inline std::ostream& operator<<(std::ostream& out, const IndexedAttributeSpec& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidDerivedAttributeSpec : public ::apache::thrift::TException {
 public:

  InvalidDerivedAttributeSpec(const InvalidDerivedAttributeSpec&);
  InvalidDerivedAttributeSpec& operator=(const InvalidDerivedAttributeSpec&);
  InvalidDerivedAttributeSpec() : reason() {
  }

  virtual ~InvalidDerivedAttributeSpec() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const InvalidDerivedAttributeSpec & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidDerivedAttributeSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidDerivedAttributeSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidDerivedAttributeSpec &a, InvalidDerivedAttributeSpec &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidDerivedAttributeSpec& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidIndexedAttributeSpec : public ::apache::thrift::TException {
 public:

  InvalidIndexedAttributeSpec(const InvalidIndexedAttributeSpec&);
  InvalidIndexedAttributeSpec& operator=(const InvalidIndexedAttributeSpec&);
  InvalidIndexedAttributeSpec() : reason() {
  }

  virtual ~InvalidIndexedAttributeSpec() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const InvalidIndexedAttributeSpec & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidIndexedAttributeSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidIndexedAttributeSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidIndexedAttributeSpec &a, InvalidIndexedAttributeSpec &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidIndexedAttributeSpec& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidMetamodel : public ::apache::thrift::TException {
 public:

  InvalidMetamodel(const InvalidMetamodel&);
  InvalidMetamodel& operator=(const InvalidMetamodel&);
  InvalidMetamodel() : reason() {
  }

  virtual ~InvalidMetamodel() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const InvalidMetamodel & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidMetamodel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidMetamodel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidMetamodel &a, InvalidMetamodel &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidMetamodel& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidPollingConfiguration : public ::apache::thrift::TException {
 public:

  InvalidPollingConfiguration(const InvalidPollingConfiguration&);
  InvalidPollingConfiguration& operator=(const InvalidPollingConfiguration&);
  InvalidPollingConfiguration() : reason() {
  }

  virtual ~InvalidPollingConfiguration() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const InvalidPollingConfiguration & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidPollingConfiguration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidPollingConfiguration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidPollingConfiguration &a, InvalidPollingConfiguration &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidPollingConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidQuery : public ::apache::thrift::TException {
 public:

  InvalidQuery(const InvalidQuery&);
  InvalidQuery& operator=(const InvalidQuery&);
  InvalidQuery() : reason() {
  }

  virtual ~InvalidQuery() throw();
  std::string reason;

  void __set_reason(const std::string& val);

  bool operator == (const InvalidQuery & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidQuery &a, InvalidQuery &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidQuery& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidTransformation {
 public:

  InvalidTransformation(const InvalidTransformation&);
  InvalidTransformation& operator=(const InvalidTransformation&);
  InvalidTransformation() : reason(), location() {
  }

  virtual ~InvalidTransformation() throw();
  std::string reason;
  std::string location;

  void __set_reason(const std::string& val);

  void __set_location(const std::string& val);

  bool operator == (const InvalidTransformation & rhs) const
  {
    if (!(reason == rhs.reason))
      return false;
    if (!(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const InvalidTransformation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidTransformation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InvalidTransformation &a, InvalidTransformation &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidTransformation& obj)
{
  obj.printTo(out);
  return out;
}


class MetamodelParserDetails {
 public:

  MetamodelParserDetails(const MetamodelParserDetails&);
  MetamodelParserDetails& operator=(const MetamodelParserDetails&);
  MetamodelParserDetails() : identifier() {
  }

  virtual ~MetamodelParserDetails() throw();
  std::set<std::string>  fileExtensions;
  std::string identifier;

  void __set_fileExtensions(const std::set<std::string> & val);

  void __set_identifier(const std::string& val);

  bool operator == (const MetamodelParserDetails & rhs) const
  {
    if (!(fileExtensions == rhs.fileExtensions))
      return false;
    if (!(identifier == rhs.identifier))
      return false;
    return true;
  }
  bool operator != (const MetamodelParserDetails &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetamodelParserDetails & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MetamodelParserDetails &a, MetamodelParserDetails &b);

inline std::ostream& operator<<(std::ostream& out, const MetamodelParserDetails& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MixedReference__isset {
  _MixedReference__isset() : id(false), position(false) {}
  bool id :1;
  bool position :1;
} _MixedReference__isset;

class MixedReference {
 public:

  MixedReference(const MixedReference&);
  MixedReference& operator=(const MixedReference&);
  MixedReference() : id(), position(0) {
  }

  virtual ~MixedReference() throw();
  std::string id;
  int32_t position;

  _MixedReference__isset __isset;

  void __set_id(const std::string& val);

  void __set_position(const int32_t val);

  bool operator == (const MixedReference & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.position != rhs.__isset.position)
      return false;
    else if (__isset.position && !(position == rhs.position))
      return false;
    return true;
  }
  bool operator != (const MixedReference &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MixedReference & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MixedReference &a, MixedReference &b);

inline std::ostream& operator<<(std::ostream& out, const MixedReference& obj)
{
  obj.printTo(out);
  return out;
}


class ModelSpec {
 public:

  ModelSpec(const ModelSpec&);
  ModelSpec& operator=(const ModelSpec&);
  ModelSpec() : uri() {
  }

  virtual ~ModelSpec() throw();
  std::string uri;
  std::vector<std::string>  metamodelUris;

  void __set_uri(const std::string& val);

  void __set_metamodelUris(const std::vector<std::string> & val);

  bool operator == (const ModelSpec & rhs) const
  {
    if (!(uri == rhs.uri))
      return false;
    if (!(metamodelUris == rhs.metamodelUris))
      return false;
    return true;
  }
  bool operator != (const ModelSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelSpec &a, ModelSpec &b);

inline std::ostream& operator<<(std::ostream& out, const ModelSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Repository__isset {
  _Repository__isset() : isFrozen(true) {}
  bool isFrozen :1;
} _Repository__isset;

class Repository {
 public:

  Repository(const Repository&);
  Repository& operator=(const Repository&);
  Repository() : uri(), type(), isFrozen(false) {
  }

  virtual ~Repository() throw();
  std::string uri;
  std::string type;
  bool isFrozen;

  _Repository__isset __isset;

  void __set_uri(const std::string& val);

  void __set_type(const std::string& val);

  void __set_isFrozen(const bool val);

  bool operator == (const Repository & rhs) const
  {
    if (!(uri == rhs.uri))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.isFrozen != rhs.__isset.isFrozen)
      return false;
    else if (__isset.isFrozen && !(isFrozen == rhs.isFrozen))
      return false;
    return true;
  }
  bool operator != (const Repository &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Repository & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Repository &a, Repository &b);

inline std::ostream& operator<<(std::ostream& out, const Repository& obj)
{
  obj.printTo(out);
  return out;
}


class Slot {
 public:

  Slot(const Slot&);
  Slot& operator=(const Slot&);
  Slot() : name() {
  }

  virtual ~Slot() throw();
  std::string name;

  void __set_name(const std::string& val);

  bool operator == (const Slot & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Slot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Slot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Slot &a, Slot &b);

inline std::ostream& operator<<(std::ostream& out, const Slot& obj)
{
  obj.printTo(out);
  return out;
}


class SlotMetadata {
 public:

  SlotMetadata(const SlotMetadata&);
  SlotMetadata& operator=(const SlotMetadata&);
  SlotMetadata() : name(), type(), isMany(0), isOrdered(0), isUnique(0) {
  }

  virtual ~SlotMetadata() throw();
  std::string name;
  std::string type;
  bool isMany;
  bool isOrdered;
  bool isUnique;

  void __set_name(const std::string& val);

  void __set_type(const std::string& val);

  void __set_isMany(const bool val);

  void __set_isOrdered(const bool val);

  void __set_isUnique(const bool val);

  bool operator == (const SlotMetadata & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(isMany == rhs.isMany))
      return false;
    if (!(isOrdered == rhs.isOrdered))
      return false;
    if (!(isUnique == rhs.isUnique))
      return false;
    return true;
  }
  bool operator != (const SlotMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SlotMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SlotMetadata &a, SlotMetadata &b);

inline std::ostream& operator<<(std::ostream& out, const SlotMetadata& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SlotValue__isset {
  _SlotValue__isset() : vBoolean(false), vByte(false), vShort(false), vInteger(false), vLong(false), vDouble(false), vString(false), vBooleans(false), vBytes(false), vShorts(false), vIntegers(false), vLongs(false), vDoubles(false), vStrings(false), vLists(false) {}
  bool vBoolean :1;
  bool vByte :1;
  bool vShort :1;
  bool vInteger :1;
  bool vLong :1;
  bool vDouble :1;
  bool vString :1;
  bool vBooleans :1;
  bool vBytes :1;
  bool vShorts :1;
  bool vIntegers :1;
  bool vLongs :1;
  bool vDoubles :1;
  bool vStrings :1;
  bool vLists :1;
} _SlotValue__isset;

class SlotValue {
 public:

  SlotValue(const SlotValue&);
  SlotValue& operator=(const SlotValue&);
  SlotValue() : vBoolean(0), vByte(0), vShort(0), vInteger(0), vLong(0), vDouble(0), vString(), vBytes() {
  }

  virtual ~SlotValue() throw();
  bool vBoolean;
  int8_t vByte;
  int16_t vShort;
  int32_t vInteger;
  int64_t vLong;
  double vDouble;
  std::string vString;
  std::vector<bool>  vBooleans;
  std::string vBytes;
  std::vector<int16_t>  vShorts;
  std::vector<int32_t>  vIntegers;
  std::vector<int64_t>  vLongs;
  std::vector<double>  vDoubles;
  std::vector<std::string>  vStrings;
  std::vector<SlotValue>  vLists;

  _SlotValue__isset __isset;

  void __set_vBoolean(const bool val);

  void __set_vByte(const int8_t val);

  void __set_vShort(const int16_t val);

  void __set_vInteger(const int32_t val);

  void __set_vLong(const int64_t val);

  void __set_vDouble(const double val);

  void __set_vString(const std::string& val);

  void __set_vBooleans(const std::vector<bool> & val);

  void __set_vBytes(const std::string& val);

  void __set_vShorts(const std::vector<int16_t> & val);

  void __set_vIntegers(const std::vector<int32_t> & val);

  void __set_vLongs(const std::vector<int64_t> & val);

  void __set_vDoubles(const std::vector<double> & val);

  void __set_vStrings(const std::vector<std::string> & val);

  void __set_vLists(const std::vector<SlotValue> & val);

  bool operator == (const SlotValue & rhs) const
  {
    if (__isset.vBoolean != rhs.__isset.vBoolean)
      return false;
    else if (__isset.vBoolean && !(vBoolean == rhs.vBoolean))
      return false;
    if (__isset.vByte != rhs.__isset.vByte)
      return false;
    else if (__isset.vByte && !(vByte == rhs.vByte))
      return false;
    if (__isset.vShort != rhs.__isset.vShort)
      return false;
    else if (__isset.vShort && !(vShort == rhs.vShort))
      return false;
    if (__isset.vInteger != rhs.__isset.vInteger)
      return false;
    else if (__isset.vInteger && !(vInteger == rhs.vInteger))
      return false;
    if (__isset.vLong != rhs.__isset.vLong)
      return false;
    else if (__isset.vLong && !(vLong == rhs.vLong))
      return false;
    if (__isset.vDouble != rhs.__isset.vDouble)
      return false;
    else if (__isset.vDouble && !(vDouble == rhs.vDouble))
      return false;
    if (__isset.vString != rhs.__isset.vString)
      return false;
    else if (__isset.vString && !(vString == rhs.vString))
      return false;
    if (__isset.vBooleans != rhs.__isset.vBooleans)
      return false;
    else if (__isset.vBooleans && !(vBooleans == rhs.vBooleans))
      return false;
    if (__isset.vBytes != rhs.__isset.vBytes)
      return false;
    else if (__isset.vBytes && !(vBytes == rhs.vBytes))
      return false;
    if (__isset.vShorts != rhs.__isset.vShorts)
      return false;
    else if (__isset.vShorts && !(vShorts == rhs.vShorts))
      return false;
    if (__isset.vIntegers != rhs.__isset.vIntegers)
      return false;
    else if (__isset.vIntegers && !(vIntegers == rhs.vIntegers))
      return false;
    if (__isset.vLongs != rhs.__isset.vLongs)
      return false;
    else if (__isset.vLongs && !(vLongs == rhs.vLongs))
      return false;
    if (__isset.vDoubles != rhs.__isset.vDoubles)
      return false;
    else if (__isset.vDoubles && !(vDoubles == rhs.vDoubles))
      return false;
    if (__isset.vStrings != rhs.__isset.vStrings)
      return false;
    else if (__isset.vStrings && !(vStrings == rhs.vStrings))
      return false;
    if (__isset.vLists != rhs.__isset.vLists)
      return false;
    else if (__isset.vLists && !(vLists == rhs.vLists))
      return false;
    return true;
  }
  bool operator != (const SlotValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SlotValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SlotValue &a, SlotValue &b);

inline std::ostream& operator<<(std::ostream& out, const SlotValue& obj)
{
  obj.printTo(out);
  return out;
}


class Subscription {
 public:

  Subscription(const Subscription&);
  Subscription& operator=(const Subscription&);
  Subscription() : host(), port(0), queueAddress(), queueName(), sslRequired(false) {
  }

  virtual ~Subscription() throw();
  std::string host;
  int32_t port;
  std::string queueAddress;
  std::string queueName;
  bool sslRequired;

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_queueAddress(const std::string& val);

  void __set_queueName(const std::string& val);

  void __set_sslRequired(const bool val);

  bool operator == (const Subscription & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(queueAddress == rhs.queueAddress))
      return false;
    if (!(queueName == rhs.queueName))
      return false;
    if (!(sslRequired == rhs.sslRequired))
      return false;
    return true;
  }
  bool operator != (const Subscription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Subscription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Subscription &a, Subscription &b);

inline std::ostream& operator<<(std::ostream& out, const Subscription& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnknownQueryLanguage__isset {
  _UnknownQueryLanguage__isset() : queryLanguage(false) {}
  bool queryLanguage :1;
} _UnknownQueryLanguage__isset;

class UnknownQueryLanguage : public ::apache::thrift::TException {
 public:

  UnknownQueryLanguage(const UnknownQueryLanguage&);
  UnknownQueryLanguage& operator=(const UnknownQueryLanguage&);
  UnknownQueryLanguage() : queryLanguage() {
  }

  virtual ~UnknownQueryLanguage() throw();
  std::string queryLanguage;

  _UnknownQueryLanguage__isset __isset;

  void __set_queryLanguage(const std::string& val);

  bool operator == (const UnknownQueryLanguage & rhs) const
  {
    if (__isset.queryLanguage != rhs.__isset.queryLanguage)
      return false;
    else if (__isset.queryLanguage && !(queryLanguage == rhs.queryLanguage))
      return false;
    return true;
  }
  bool operator != (const UnknownQueryLanguage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownQueryLanguage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnknownQueryLanguage &a, UnknownQueryLanguage &b);

inline std::ostream& operator<<(std::ostream& out, const UnknownQueryLanguage& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnknownRepositoryType__isset {
  _UnknownRepositoryType__isset() : repositoryType(false) {}
  bool repositoryType :1;
} _UnknownRepositoryType__isset;

class UnknownRepositoryType : public ::apache::thrift::TException {
 public:

  UnknownRepositoryType(const UnknownRepositoryType&);
  UnknownRepositoryType& operator=(const UnknownRepositoryType&);
  UnknownRepositoryType() : repositoryType() {
  }

  virtual ~UnknownRepositoryType() throw();
  std::string repositoryType;

  _UnknownRepositoryType__isset __isset;

  void __set_repositoryType(const std::string& val);

  bool operator == (const UnknownRepositoryType & rhs) const
  {
    if (__isset.repositoryType != rhs.__isset.repositoryType)
      return false;
    else if (__isset.repositoryType && !(repositoryType == rhs.repositoryType))
      return false;
    return true;
  }
  bool operator != (const UnknownRepositoryType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownRepositoryType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnknownRepositoryType &a, UnknownRepositoryType &b);

inline std::ostream& operator<<(std::ostream& out, const UnknownRepositoryType& obj)
{
  obj.printTo(out);
  return out;
}


class UserExists : public ::apache::thrift::TException {
 public:

  UserExists(const UserExists&);
  UserExists& operator=(const UserExists&);
  UserExists() {
  }

  virtual ~UserExists() throw();

  bool operator == (const UserExists & /* rhs */) const
  {
    return true;
  }
  bool operator != (const UserExists &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserExists & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UserExists &a, UserExists &b);

inline std::ostream& operator<<(std::ostream& out, const UserExists& obj)
{
  obj.printTo(out);
  return out;
}


class UserNotFound : public ::apache::thrift::TException {
 public:

  UserNotFound(const UserNotFound&);
  UserNotFound& operator=(const UserNotFound&);
  UserNotFound() {
  }

  virtual ~UserNotFound() throw();

  bool operator == (const UserNotFound & /* rhs */) const
  {
    return true;
  }
  bool operator != (const UserNotFound &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserNotFound & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UserNotFound &a, UserNotFound &b);

inline std::ostream& operator<<(std::ostream& out, const UserNotFound& obj)
{
  obj.printTo(out);
  return out;
}


class UserProfile {
 public:

  UserProfile(const UserProfile&);
  UserProfile& operator=(const UserProfile&);
  UserProfile() : realName(), admin(0) {
  }

  virtual ~UserProfile() throw();
  std::string realName;
  bool admin;

  void __set_realName(const std::string& val);

  void __set_admin(const bool val);

  bool operator == (const UserProfile & rhs) const
  {
    if (!(realName == rhs.realName))
      return false;
    if (!(admin == rhs.admin))
      return false;
    return true;
  }
  bool operator != (const UserProfile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserProfile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UserProfile &a, UserProfile &b);

inline std::ostream& operator<<(std::ostream& out, const UserProfile& obj)
{
  obj.printTo(out);
  return out;
}


class VCSAuthenticationFailed : public ::apache::thrift::TException {
 public:

  VCSAuthenticationFailed(const VCSAuthenticationFailed&);
  VCSAuthenticationFailed& operator=(const VCSAuthenticationFailed&);
  VCSAuthenticationFailed() {
  }

  virtual ~VCSAuthenticationFailed() throw();

  bool operator == (const VCSAuthenticationFailed & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VCSAuthenticationFailed &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VCSAuthenticationFailed & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(VCSAuthenticationFailed &a, VCSAuthenticationFailed &b);

inline std::ostream& operator<<(std::ostream& out, const VCSAuthenticationFailed& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Value__isset {
  _Value__isset() : vBoolean(false), vByte(false), vShort(false), vInteger(false), vLong(false), vDouble(false), vString(false) {}
  bool vBoolean :1;
  bool vByte :1;
  bool vShort :1;
  bool vInteger :1;
  bool vLong :1;
  bool vDouble :1;
  bool vString :1;
} _Value__isset;

class Value {
 public:

  Value(const Value&);
  Value& operator=(const Value&);
  Value() : vBoolean(0), vByte(0), vShort(0), vInteger(0), vLong(0), vDouble(0), vString() {
  }

  virtual ~Value() throw();
  bool vBoolean;
  int8_t vByte;
  int16_t vShort;
  int32_t vInteger;
  int64_t vLong;
  double vDouble;
  std::string vString;

  _Value__isset __isset;

  void __set_vBoolean(const bool val);

  void __set_vByte(const int8_t val);

  void __set_vShort(const int16_t val);

  void __set_vInteger(const int32_t val);

  void __set_vLong(const int64_t val);

  void __set_vDouble(const double val);

  void __set_vString(const std::string& val);

  bool operator == (const Value & rhs) const
  {
    if (__isset.vBoolean != rhs.__isset.vBoolean)
      return false;
    else if (__isset.vBoolean && !(vBoolean == rhs.vBoolean))
      return false;
    if (__isset.vByte != rhs.__isset.vByte)
      return false;
    else if (__isset.vByte && !(vByte == rhs.vByte))
      return false;
    if (__isset.vShort != rhs.__isset.vShort)
      return false;
    else if (__isset.vShort && !(vShort == rhs.vShort))
      return false;
    if (__isset.vInteger != rhs.__isset.vInteger)
      return false;
    else if (__isset.vInteger && !(vInteger == rhs.vInteger))
      return false;
    if (__isset.vLong != rhs.__isset.vLong)
      return false;
    else if (__isset.vLong && !(vLong == rhs.vLong))
      return false;
    if (__isset.vDouble != rhs.__isset.vDouble)
      return false;
    else if (__isset.vDouble && !(vDouble == rhs.vDouble))
      return false;
    if (__isset.vString != rhs.__isset.vString)
      return false;
    else if (__isset.vString && !(vString == rhs.vString))
      return false;
    return true;
  }
  bool operator != (const Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Value &a, Value &b);

inline std::ostream& operator<<(std::ostream& out, const Value& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AttributeSlot__isset {
  _AttributeSlot__isset() : value(false) {}
  bool value :1;
} _AttributeSlot__isset;

class AttributeSlot {
 public:

  AttributeSlot(const AttributeSlot&);
  AttributeSlot& operator=(const AttributeSlot&);
  AttributeSlot() : name() {
  }

  virtual ~AttributeSlot() throw();
  std::string name;
  SlotValue value;

  _AttributeSlot__isset __isset;

  void __set_name(const std::string& val);

  void __set_value(const SlotValue& val);

  bool operator == (const AttributeSlot & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const AttributeSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AttributeSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AttributeSlot &a, AttributeSlot &b);

inline std::ostream& operator<<(std::ostream& out, const AttributeSlot& obj)
{
  obj.printTo(out);
  return out;
}


class HawkAttributeRemovalEvent {
 public:

  HawkAttributeRemovalEvent(const HawkAttributeRemovalEvent&);
  HawkAttributeRemovalEvent& operator=(const HawkAttributeRemovalEvent&);
  HawkAttributeRemovalEvent() : id(), attribute() {
  }

  virtual ~HawkAttributeRemovalEvent() throw();
  CommitItem vcsItem;
  std::string id;
  std::string attribute;

  void __set_vcsItem(const CommitItem& val);

  void __set_id(const std::string& val);

  void __set_attribute(const std::string& val);

  bool operator == (const HawkAttributeRemovalEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(attribute == rhs.attribute))
      return false;
    return true;
  }
  bool operator != (const HawkAttributeRemovalEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkAttributeRemovalEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkAttributeRemovalEvent &a, HawkAttributeRemovalEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkAttributeRemovalEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkAttributeUpdateEvent {
 public:

  HawkAttributeUpdateEvent(const HawkAttributeUpdateEvent&);
  HawkAttributeUpdateEvent& operator=(const HawkAttributeUpdateEvent&);
  HawkAttributeUpdateEvent() : id(), attribute() {
  }

  virtual ~HawkAttributeUpdateEvent() throw();
  CommitItem vcsItem;
  std::string id;
  std::string attribute;
  SlotValue value;

  void __set_vcsItem(const CommitItem& val);

  void __set_id(const std::string& val);

  void __set_attribute(const std::string& val);

  void __set_value(const SlotValue& val);

  bool operator == (const HawkAttributeUpdateEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(attribute == rhs.attribute))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const HawkAttributeUpdateEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkAttributeUpdateEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkAttributeUpdateEvent &a, HawkAttributeUpdateEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkAttributeUpdateEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkFileAdditionEvent {
 public:

  HawkFileAdditionEvent(const HawkFileAdditionEvent&);
  HawkFileAdditionEvent& operator=(const HawkFileAdditionEvent&);
  HawkFileAdditionEvent() {
  }

  virtual ~HawkFileAdditionEvent() throw();
  CommitItem vcsItem;

  void __set_vcsItem(const CommitItem& val);

  bool operator == (const HawkFileAdditionEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    return true;
  }
  bool operator != (const HawkFileAdditionEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkFileAdditionEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkFileAdditionEvent &a, HawkFileAdditionEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkFileAdditionEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkFileRemovalEvent {
 public:

  HawkFileRemovalEvent(const HawkFileRemovalEvent&);
  HawkFileRemovalEvent& operator=(const HawkFileRemovalEvent&);
  HawkFileRemovalEvent() {
  }

  virtual ~HawkFileRemovalEvent() throw();
  CommitItem vcsItem;

  void __set_vcsItem(const CommitItem& val);

  bool operator == (const HawkFileRemovalEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    return true;
  }
  bool operator != (const HawkFileRemovalEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkFileRemovalEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkFileRemovalEvent &a, HawkFileRemovalEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkFileRemovalEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkModelElementAdditionEvent {
 public:

  HawkModelElementAdditionEvent(const HawkModelElementAdditionEvent&);
  HawkModelElementAdditionEvent& operator=(const HawkModelElementAdditionEvent&);
  HawkModelElementAdditionEvent() : metamodelURI(), typeName(), id() {
  }

  virtual ~HawkModelElementAdditionEvent() throw();
  CommitItem vcsItem;
  std::string metamodelURI;
  std::string typeName;
  std::string id;

  void __set_vcsItem(const CommitItem& val);

  void __set_metamodelURI(const std::string& val);

  void __set_typeName(const std::string& val);

  void __set_id(const std::string& val);

  bool operator == (const HawkModelElementAdditionEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(metamodelURI == rhs.metamodelURI))
      return false;
    if (!(typeName == rhs.typeName))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const HawkModelElementAdditionEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkModelElementAdditionEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkModelElementAdditionEvent &a, HawkModelElementAdditionEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkModelElementAdditionEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkModelElementRemovalEvent {
 public:

  HawkModelElementRemovalEvent(const HawkModelElementRemovalEvent&);
  HawkModelElementRemovalEvent& operator=(const HawkModelElementRemovalEvent&);
  HawkModelElementRemovalEvent() : id() {
  }

  virtual ~HawkModelElementRemovalEvent() throw();
  CommitItem vcsItem;
  std::string id;

  void __set_vcsItem(const CommitItem& val);

  void __set_id(const std::string& val);

  bool operator == (const HawkModelElementRemovalEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const HawkModelElementRemovalEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkModelElementRemovalEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkModelElementRemovalEvent &a, HawkModelElementRemovalEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkModelElementRemovalEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkReferenceAdditionEvent {
 public:

  HawkReferenceAdditionEvent(const HawkReferenceAdditionEvent&);
  HawkReferenceAdditionEvent& operator=(const HawkReferenceAdditionEvent&);
  HawkReferenceAdditionEvent() : sourceId(), targetId(), refName() {
  }

  virtual ~HawkReferenceAdditionEvent() throw();
  CommitItem vcsItem;
  std::string sourceId;
  std::string targetId;
  std::string refName;

  void __set_vcsItem(const CommitItem& val);

  void __set_sourceId(const std::string& val);

  void __set_targetId(const std::string& val);

  void __set_refName(const std::string& val);

  bool operator == (const HawkReferenceAdditionEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(sourceId == rhs.sourceId))
      return false;
    if (!(targetId == rhs.targetId))
      return false;
    if (!(refName == rhs.refName))
      return false;
    return true;
  }
  bool operator != (const HawkReferenceAdditionEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkReferenceAdditionEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkReferenceAdditionEvent &a, HawkReferenceAdditionEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkReferenceAdditionEvent& obj)
{
  obj.printTo(out);
  return out;
}


class HawkReferenceRemovalEvent {
 public:

  HawkReferenceRemovalEvent(const HawkReferenceRemovalEvent&);
  HawkReferenceRemovalEvent& operator=(const HawkReferenceRemovalEvent&);
  HawkReferenceRemovalEvent() : sourceId(), targetId(), refName() {
  }

  virtual ~HawkReferenceRemovalEvent() throw();
  CommitItem vcsItem;
  std::string sourceId;
  std::string targetId;
  std::string refName;

  void __set_vcsItem(const CommitItem& val);

  void __set_sourceId(const std::string& val);

  void __set_targetId(const std::string& val);

  void __set_refName(const std::string& val);

  bool operator == (const HawkReferenceRemovalEvent & rhs) const
  {
    if (!(vcsItem == rhs.vcsItem))
      return false;
    if (!(sourceId == rhs.sourceId))
      return false;
    if (!(targetId == rhs.targetId))
      return false;
    if (!(refName == rhs.refName))
      return false;
    return true;
  }
  bool operator != (const HawkReferenceRemovalEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkReferenceRemovalEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkReferenceRemovalEvent &a, HawkReferenceRemovalEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkReferenceRemovalEvent& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidModelSpec {
 public:

  InvalidModelSpec(const InvalidModelSpec&);
  InvalidModelSpec& operator=(const InvalidModelSpec&);
  InvalidModelSpec() : reason() {
  }

  virtual ~InvalidModelSpec() throw();
  ModelSpec spec;
  std::string reason;

  void __set_spec(const ModelSpec& val);

  void __set_reason(const std::string& val);

  bool operator == (const InvalidModelSpec & rhs) const
  {
    if (!(spec == rhs.spec))
      return false;
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const InvalidModelSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidModelSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InvalidModelSpec &a, InvalidModelSpec &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidModelSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ModelElementType__isset {
  _ModelElementType__isset() : attributes(false), references(false) {}
  bool attributes :1;
  bool references :1;
} _ModelElementType__isset;

class ModelElementType {
 public:

  ModelElementType(const ModelElementType&);
  ModelElementType& operator=(const ModelElementType&);
  ModelElementType() : id(), metamodelUri(), typeName() {
  }

  virtual ~ModelElementType() throw();
  std::string id;
  std::string metamodelUri;
  std::string typeName;
  std::vector<SlotMetadata>  attributes;
  std::vector<SlotMetadata>  references;

  _ModelElementType__isset __isset;

  void __set_id(const std::string& val);

  void __set_metamodelUri(const std::string& val);

  void __set_typeName(const std::string& val);

  void __set_attributes(const std::vector<SlotMetadata> & val);

  void __set_references(const std::vector<SlotMetadata> & val);

  bool operator == (const ModelElementType & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(metamodelUri == rhs.metamodelUri))
      return false;
    if (!(typeName == rhs.typeName))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.references != rhs.__isset.references)
      return false;
    else if (__isset.references && !(references == rhs.references))
      return false;
    return true;
  }
  bool operator != (const ModelElementType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelElementType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelElementType &a, ModelElementType &b);

inline std::ostream& operator<<(std::ostream& out, const ModelElementType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ReferenceSlot__isset {
  _ReferenceSlot__isset() : position(false), positions(false), id(false), ids(false), mixed(false) {}
  bool position :1;
  bool positions :1;
  bool id :1;
  bool ids :1;
  bool mixed :1;
} _ReferenceSlot__isset;

class ReferenceSlot {
 public:

  ReferenceSlot(const ReferenceSlot&);
  ReferenceSlot& operator=(const ReferenceSlot&);
  ReferenceSlot() : name(), position(0), id() {
  }

  virtual ~ReferenceSlot() throw();
  std::string name;
  int32_t position;
  std::vector<int32_t>  positions;
  std::string id;
  std::vector<std::string>  ids;
  std::vector<MixedReference>  mixed;

  _ReferenceSlot__isset __isset;

  void __set_name(const std::string& val);

  void __set_position(const int32_t val);

  void __set_positions(const std::vector<int32_t> & val);

  void __set_id(const std::string& val);

  void __set_ids(const std::vector<std::string> & val);

  void __set_mixed(const std::vector<MixedReference> & val);

  bool operator == (const ReferenceSlot & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.position != rhs.__isset.position)
      return false;
    else if (__isset.position && !(position == rhs.position))
      return false;
    if (__isset.positions != rhs.__isset.positions)
      return false;
    else if (__isset.positions && !(positions == rhs.positions))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.ids != rhs.__isset.ids)
      return false;
    else if (__isset.ids && !(ids == rhs.ids))
      return false;
    if (__isset.mixed != rhs.__isset.mixed)
      return false;
    else if (__isset.mixed && !(mixed == rhs.mixed))
      return false;
    return true;
  }
  bool operator != (const ReferenceSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReferenceSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReferenceSlot &a, ReferenceSlot &b);

inline std::ostream& operator<<(std::ostream& out, const ReferenceSlot& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkChangeEvent__isset {
  _HawkChangeEvent__isset() : modelElementAddition(false), modelElementRemoval(false), modelElementAttributeUpdate(false), modelElementAttributeRemoval(false), referenceAddition(false), referenceRemoval(false), syncStart(false), syncEnd(false), fileAddition(false), fileRemoval(false) {}
  bool modelElementAddition :1;
  bool modelElementRemoval :1;
  bool modelElementAttributeUpdate :1;
  bool modelElementAttributeRemoval :1;
  bool referenceAddition :1;
  bool referenceRemoval :1;
  bool syncStart :1;
  bool syncEnd :1;
  bool fileAddition :1;
  bool fileRemoval :1;
} _HawkChangeEvent__isset;

class HawkChangeEvent {
 public:

  HawkChangeEvent(const HawkChangeEvent&);
  HawkChangeEvent& operator=(const HawkChangeEvent&);
  HawkChangeEvent() {
  }

  virtual ~HawkChangeEvent() throw();
  HawkModelElementAdditionEvent modelElementAddition;
  HawkModelElementRemovalEvent modelElementRemoval;
  HawkAttributeUpdateEvent modelElementAttributeUpdate;
  HawkAttributeRemovalEvent modelElementAttributeRemoval;
  HawkReferenceAdditionEvent referenceAddition;
  HawkReferenceRemovalEvent referenceRemoval;
  HawkSynchronizationStartEvent syncStart;
  HawkSynchronizationEndEvent syncEnd;
  HawkFileAdditionEvent fileAddition;
  HawkFileRemovalEvent fileRemoval;

  _HawkChangeEvent__isset __isset;

  void __set_modelElementAddition(const HawkModelElementAdditionEvent& val);

  void __set_modelElementRemoval(const HawkModelElementRemovalEvent& val);

  void __set_modelElementAttributeUpdate(const HawkAttributeUpdateEvent& val);

  void __set_modelElementAttributeRemoval(const HawkAttributeRemovalEvent& val);

  void __set_referenceAddition(const HawkReferenceAdditionEvent& val);

  void __set_referenceRemoval(const HawkReferenceRemovalEvent& val);

  void __set_syncStart(const HawkSynchronizationStartEvent& val);

  void __set_syncEnd(const HawkSynchronizationEndEvent& val);

  void __set_fileAddition(const HawkFileAdditionEvent& val);

  void __set_fileRemoval(const HawkFileRemovalEvent& val);

  bool operator == (const HawkChangeEvent & rhs) const
  {
    if (__isset.modelElementAddition != rhs.__isset.modelElementAddition)
      return false;
    else if (__isset.modelElementAddition && !(modelElementAddition == rhs.modelElementAddition))
      return false;
    if (__isset.modelElementRemoval != rhs.__isset.modelElementRemoval)
      return false;
    else if (__isset.modelElementRemoval && !(modelElementRemoval == rhs.modelElementRemoval))
      return false;
    if (__isset.modelElementAttributeUpdate != rhs.__isset.modelElementAttributeUpdate)
      return false;
    else if (__isset.modelElementAttributeUpdate && !(modelElementAttributeUpdate == rhs.modelElementAttributeUpdate))
      return false;
    if (__isset.modelElementAttributeRemoval != rhs.__isset.modelElementAttributeRemoval)
      return false;
    else if (__isset.modelElementAttributeRemoval && !(modelElementAttributeRemoval == rhs.modelElementAttributeRemoval))
      return false;
    if (__isset.referenceAddition != rhs.__isset.referenceAddition)
      return false;
    else if (__isset.referenceAddition && !(referenceAddition == rhs.referenceAddition))
      return false;
    if (__isset.referenceRemoval != rhs.__isset.referenceRemoval)
      return false;
    else if (__isset.referenceRemoval && !(referenceRemoval == rhs.referenceRemoval))
      return false;
    if (__isset.syncStart != rhs.__isset.syncStart)
      return false;
    else if (__isset.syncStart && !(syncStart == rhs.syncStart))
      return false;
    if (__isset.syncEnd != rhs.__isset.syncEnd)
      return false;
    else if (__isset.syncEnd && !(syncEnd == rhs.syncEnd))
      return false;
    if (__isset.fileAddition != rhs.__isset.fileAddition)
      return false;
    else if (__isset.fileAddition && !(fileAddition == rhs.fileAddition))
      return false;
    if (__isset.fileRemoval != rhs.__isset.fileRemoval)
      return false;
    else if (__isset.fileRemoval && !(fileRemoval == rhs.fileRemoval))
      return false;
    return true;
  }
  bool operator != (const HawkChangeEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkChangeEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkChangeEvent &a, HawkChangeEvent &b);

inline std::ostream& operator<<(std::ostream& out, const HawkChangeEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HawkQueryOptions__isset {
  _HawkQueryOptions__isset() : repositoryPattern(true), filePatterns(false), defaultNamespaces(false), includeAttributes(true), includeReferences(true), includeNodeIDs(true), includeContained(true), effectiveMetamodelIncludes(false), effectiveMetamodelExcludes(false), includeDerived(true) {}
  bool repositoryPattern :1;
  bool filePatterns :1;
  bool defaultNamespaces :1;
  bool includeAttributes :1;
  bool includeReferences :1;
  bool includeNodeIDs :1;
  bool includeContained :1;
  bool effectiveMetamodelIncludes :1;
  bool effectiveMetamodelExcludes :1;
  bool includeDerived :1;
} _HawkQueryOptions__isset;

class HawkQueryOptions {
 public:

  HawkQueryOptions(const HawkQueryOptions&);
  HawkQueryOptions& operator=(const HawkQueryOptions&);
  HawkQueryOptions() : repositoryPattern("*"), defaultNamespaces(), includeAttributes(true), includeReferences(true), includeNodeIDs(false), includeContained(true), includeDerived(true) {
  }

  virtual ~HawkQueryOptions() throw();
  std::string repositoryPattern;
  std::vector<std::string>  filePatterns;
  std::string defaultNamespaces;
  bool includeAttributes;
  bool includeReferences;
  bool includeNodeIDs;
  bool includeContained;
  std::map<std::string, std::map<std::string, std::set<std::string> > >  effectiveMetamodelIncludes;
  std::map<std::string, std::map<std::string, std::set<std::string> > >  effectiveMetamodelExcludes;
  bool includeDerived;

  _HawkQueryOptions__isset __isset;

  void __set_repositoryPattern(const std::string& val);

  void __set_filePatterns(const std::vector<std::string> & val);

  void __set_defaultNamespaces(const std::string& val);

  void __set_includeAttributes(const bool val);

  void __set_includeReferences(const bool val);

  void __set_includeNodeIDs(const bool val);

  void __set_includeContained(const bool val);

  void __set_effectiveMetamodelIncludes(const std::map<std::string, std::map<std::string, std::set<std::string> > > & val);

  void __set_effectiveMetamodelExcludes(const std::map<std::string, std::map<std::string, std::set<std::string> > > & val);

  void __set_includeDerived(const bool val);

  bool operator == (const HawkQueryOptions & rhs) const
  {
    if (__isset.repositoryPattern != rhs.__isset.repositoryPattern)
      return false;
    else if (__isset.repositoryPattern && !(repositoryPattern == rhs.repositoryPattern))
      return false;
    if (__isset.filePatterns != rhs.__isset.filePatterns)
      return false;
    else if (__isset.filePatterns && !(filePatterns == rhs.filePatterns))
      return false;
    if (__isset.defaultNamespaces != rhs.__isset.defaultNamespaces)
      return false;
    else if (__isset.defaultNamespaces && !(defaultNamespaces == rhs.defaultNamespaces))
      return false;
    if (__isset.includeAttributes != rhs.__isset.includeAttributes)
      return false;
    else if (__isset.includeAttributes && !(includeAttributes == rhs.includeAttributes))
      return false;
    if (__isset.includeReferences != rhs.__isset.includeReferences)
      return false;
    else if (__isset.includeReferences && !(includeReferences == rhs.includeReferences))
      return false;
    if (__isset.includeNodeIDs != rhs.__isset.includeNodeIDs)
      return false;
    else if (__isset.includeNodeIDs && !(includeNodeIDs == rhs.includeNodeIDs))
      return false;
    if (__isset.includeContained != rhs.__isset.includeContained)
      return false;
    else if (__isset.includeContained && !(includeContained == rhs.includeContained))
      return false;
    if (__isset.effectiveMetamodelIncludes != rhs.__isset.effectiveMetamodelIncludes)
      return false;
    else if (__isset.effectiveMetamodelIncludes && !(effectiveMetamodelIncludes == rhs.effectiveMetamodelIncludes))
      return false;
    if (__isset.effectiveMetamodelExcludes != rhs.__isset.effectiveMetamodelExcludes)
      return false;
    else if (__isset.effectiveMetamodelExcludes && !(effectiveMetamodelExcludes == rhs.effectiveMetamodelExcludes))
      return false;
    if (__isset.includeDerived != rhs.__isset.includeDerived)
      return false;
    else if (__isset.includeDerived && !(includeDerived == rhs.includeDerived))
      return false;
    return true;
  }
  bool operator != (const HawkQueryOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HawkQueryOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HawkQueryOptions &a, HawkQueryOptions &b);

inline std::ostream& operator<<(std::ostream& out, const HawkQueryOptions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ModelElement__isset {
  _ModelElement__isset() : id(false), repositoryURL(false), file(false), metamodelUri(false), typeName(false), attributes(false), references(false), containers(false) {}
  bool id :1;
  bool repositoryURL :1;
  bool file :1;
  bool metamodelUri :1;
  bool typeName :1;
  bool attributes :1;
  bool references :1;
  bool containers :1;
} _ModelElement__isset;

class ModelElement {
 public:

  ModelElement(const ModelElement&);
  ModelElement& operator=(const ModelElement&);
  ModelElement() : id(), repositoryURL(), file(), metamodelUri(), typeName() {
  }

  virtual ~ModelElement() throw();
  std::string id;
  std::string repositoryURL;
  std::string file;
  std::string metamodelUri;
  std::string typeName;
  std::vector<AttributeSlot>  attributes;
  std::vector<ReferenceSlot>  references;
  std::vector<ContainerSlot>  containers;

  _ModelElement__isset __isset;

  void __set_id(const std::string& val);

  void __set_repositoryURL(const std::string& val);

  void __set_file(const std::string& val);

  void __set_metamodelUri(const std::string& val);

  void __set_typeName(const std::string& val);

  void __set_attributes(const std::vector<AttributeSlot> & val);

  void __set_references(const std::vector<ReferenceSlot> & val);

  void __set_containers(const std::vector<ContainerSlot> & val);

  bool operator == (const ModelElement & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.repositoryURL != rhs.__isset.repositoryURL)
      return false;
    else if (__isset.repositoryURL && !(repositoryURL == rhs.repositoryURL))
      return false;
    if (__isset.file != rhs.__isset.file)
      return false;
    else if (__isset.file && !(file == rhs.file))
      return false;
    if (__isset.metamodelUri != rhs.__isset.metamodelUri)
      return false;
    else if (__isset.metamodelUri && !(metamodelUri == rhs.metamodelUri))
      return false;
    if (__isset.typeName != rhs.__isset.typeName)
      return false;
    else if (__isset.typeName && !(typeName == rhs.typeName))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.references != rhs.__isset.references)
      return false;
    else if (__isset.references && !(references == rhs.references))
      return false;
    if (__isset.containers != rhs.__isset.containers)
      return false;
    else if (__isset.containers && !(containers == rhs.containers))
      return false;
    return true;
  }
  bool operator != (const ModelElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelElement &a, ModelElement &b);

inline std::ostream& operator<<(std::ostream& out, const ModelElement& obj)
{
  obj.printTo(out);
  return out;
}


class ContainerSlot {
 public:

  ContainerSlot(const ContainerSlot&);
  ContainerSlot& operator=(const ContainerSlot&);
  ContainerSlot() : name() {
  }

  virtual ~ContainerSlot() throw();
  std::string name;
  std::vector<ModelElement>  elements;

  void __set_name(const std::string& val);

  void __set_elements(const std::vector<ModelElement> & val);

  bool operator == (const ContainerSlot & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(elements == rhs.elements))
      return false;
    return true;
  }
  bool operator != (const ContainerSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ContainerSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ContainerSlot &a, ContainerSlot &b);

inline std::ostream& operator<<(std::ostream& out, const ContainerSlot& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QueryResult__isset {
  _QueryResult__isset() : vBoolean(false), vByte(false), vShort(false), vInteger(false), vLong(false), vDouble(false), vString(false), vModelElement(false), vModelElementType(false), vMap(false), vList(false) {}
  bool vBoolean :1;
  bool vByte :1;
  bool vShort :1;
  bool vInteger :1;
  bool vLong :1;
  bool vDouble :1;
  bool vString :1;
  bool vModelElement :1;
  bool vModelElementType :1;
  bool vMap :1;
  bool vList :1;
} _QueryResult__isset;

class QueryResult {
 public:

  QueryResult(const QueryResult&);
  QueryResult& operator=(const QueryResult&);
  QueryResult() : vBoolean(0), vByte(0), vShort(0), vInteger(0), vLong(0), vDouble(0), vString() {
  }

  virtual ~QueryResult() throw();
  bool vBoolean;
  int8_t vByte;
  int16_t vShort;
  int32_t vInteger;
  int64_t vLong;
  double vDouble;
  std::string vString;
  ModelElement vModelElement;
  ModelElementType vModelElementType;
  std::map<std::string, QueryResult>  vMap;
  std::vector<QueryResult>  vList;

  _QueryResult__isset __isset;

  void __set_vBoolean(const bool val);

  void __set_vByte(const int8_t val);

  void __set_vShort(const int16_t val);

  void __set_vInteger(const int32_t val);

  void __set_vLong(const int64_t val);

  void __set_vDouble(const double val);

  void __set_vString(const std::string& val);

  void __set_vModelElement(const ModelElement& val);

  void __set_vModelElementType(const ModelElementType& val);

  void __set_vMap(const std::map<std::string, QueryResult> & val);

  void __set_vList(const std::vector<QueryResult> & val);

  bool operator == (const QueryResult & rhs) const
  {
    if (__isset.vBoolean != rhs.__isset.vBoolean)
      return false;
    else if (__isset.vBoolean && !(vBoolean == rhs.vBoolean))
      return false;
    if (__isset.vByte != rhs.__isset.vByte)
      return false;
    else if (__isset.vByte && !(vByte == rhs.vByte))
      return false;
    if (__isset.vShort != rhs.__isset.vShort)
      return false;
    else if (__isset.vShort && !(vShort == rhs.vShort))
      return false;
    if (__isset.vInteger != rhs.__isset.vInteger)
      return false;
    else if (__isset.vInteger && !(vInteger == rhs.vInteger))
      return false;
    if (__isset.vLong != rhs.__isset.vLong)
      return false;
    else if (__isset.vLong && !(vLong == rhs.vLong))
      return false;
    if (__isset.vDouble != rhs.__isset.vDouble)
      return false;
    else if (__isset.vDouble && !(vDouble == rhs.vDouble))
      return false;
    if (__isset.vString != rhs.__isset.vString)
      return false;
    else if (__isset.vString && !(vString == rhs.vString))
      return false;
    if (__isset.vModelElement != rhs.__isset.vModelElement)
      return false;
    else if (__isset.vModelElement && !(vModelElement == rhs.vModelElement))
      return false;
    if (__isset.vModelElementType != rhs.__isset.vModelElementType)
      return false;
    else if (__isset.vModelElementType && !(vModelElementType == rhs.vModelElementType))
      return false;
    if (__isset.vMap != rhs.__isset.vMap)
      return false;
    else if (__isset.vMap && !(vMap == rhs.vMap))
      return false;
    if (__isset.vList != rhs.__isset.vList)
      return false;
    else if (__isset.vList && !(vList == rhs.vList))
      return false;
    return true;
  }
  bool operator != (const QueryResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryResult &a, QueryResult &b);

inline std::ostream& operator<<(std::ostream& out, const QueryResult& obj)
{
  obj.printTo(out);
  return out;
}


class QueryReport {
 public:

  QueryReport(const QueryReport&);
  QueryReport& operator=(const QueryReport&);
  QueryReport() : wallMillis(0), isCancelled(0) {
  }

  virtual ~QueryReport() throw();
  QueryResult result;
  int64_t wallMillis;
  bool isCancelled;

  void __set_result(const QueryResult& val);

  void __set_wallMillis(const int64_t val);

  void __set_isCancelled(const bool val);

  bool operator == (const QueryReport & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(wallMillis == rhs.wallMillis))
      return false;
    if (!(isCancelled == rhs.isCancelled))
      return false;
    return true;
  }
  bool operator != (const QueryReport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryReport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryReport &a, QueryReport &b);

inline std::ostream& operator<<(std::ostream& out, const QueryReport& obj)
{
  obj.printTo(out);
  return out;
}



#endif
