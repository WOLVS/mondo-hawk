/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "api_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kCommitItemChangeTypeValues[] = {
  CommitItemChangeType::ADDED,
  CommitItemChangeType::DELETED,
  CommitItemChangeType::REPLACED,
  CommitItemChangeType::UNKNOWN,
  CommitItemChangeType::UPDATED
};
const char* _kCommitItemChangeTypeNames[] = {
  "ADDED",
  "DELETED",
  "REPLACED",
  "UNKNOWN",
  "UPDATED"
};
const std::map<int, const char*> _CommitItemChangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCommitItemChangeTypeValues, _kCommitItemChangeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHawkPluginCategoryValues[] = {
  HawkPluginCategory::BACKEND,
  HawkPluginCategory::GRAPH_CHANGE_LISTENER,
  HawkPluginCategory::INDEX_FACTORY,
  HawkPluginCategory::METAMODEL_INTROSPECTOR,
  HawkPluginCategory::METAMODEL_RESOURCE_FACTORY,
  HawkPluginCategory::METAMODEL_UPDATER,
  HawkPluginCategory::MODEL_RESOURCE_FACTORY,
  HawkPluginCategory::MODEL_UPDATER,
  HawkPluginCategory::QUERY_ENGINE,
  HawkPluginCategory::VCS_MANAGER
};
const char* _kHawkPluginCategoryNames[] = {
  "BACKEND",
  "GRAPH_CHANGE_LISTENER",
  "INDEX_FACTORY",
  "METAMODEL_INTROSPECTOR",
  "METAMODEL_RESOURCE_FACTORY",
  "METAMODEL_UPDATER",
  "MODEL_RESOURCE_FACTORY",
  "MODEL_UPDATER",
  "QUERY_ENGINE",
  "VCS_MANAGER"
};
const std::map<int, const char*> _HawkPluginCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kHawkPluginCategoryValues, _kHawkPluginCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHawkStateValues[] = {
  HawkState::RUNNING,
  HawkState::STOPPED,
  HawkState::UPDATING
};
const char* _kHawkStateNames[] = {
  "RUNNING",
  "STOPPED",
  "UPDATING"
};
const std::map<int, const char*> _HawkState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kHawkStateValues, _kHawkStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSubscriptionDurabilityValues[] = {
  SubscriptionDurability::DEFAULT,
  SubscriptionDurability::DURABLE,
  SubscriptionDurability::TEMPORARY
};
const char* _kSubscriptionDurabilityNames[] = {
  "DEFAULT",
  "DURABLE",
  "TEMPORARY"
};
const std::map<int, const char*> _SubscriptionDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSubscriptionDurabilityValues, _kSubscriptionDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


CommitItem::~CommitItem() throw() {
}


void CommitItem::__set_repoURL(const std::string& val) {
  this->repoURL = val;
}

void CommitItem::__set_revision(const std::string& val) {
  this->revision = val;
}

void CommitItem::__set_path(const std::string& val) {
  this->path = val;
}

void CommitItem::__set_type(const CommitItemChangeType::type val) {
  this->type = val;
}

uint32_t CommitItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_repoURL = false;
  bool isset_revision = false;
  bool isset_path = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repoURL);
          isset_repoURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (CommitItemChangeType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_repoURL)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitItem");

  xfer += oprot->writeFieldBegin("repoURL", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->repoURL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitItem &a, CommitItem &b) {
  using ::std::swap;
  swap(a.repoURL, b.repoURL);
  swap(a.revision, b.revision);
  swap(a.path, b.path);
  swap(a.type, b.type);
}

CommitItem::CommitItem(const CommitItem& other1) {
  repoURL = other1.repoURL;
  revision = other1.revision;
  path = other1.path;
  type = other1.type;
}
CommitItem& CommitItem::operator=(const CommitItem& other2) {
  repoURL = other2.repoURL;
  revision = other2.revision;
  path = other2.path;
  type = other2.type;
  return *this;
}
void CommitItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitItem(";
  out << "repoURL=" << to_string(repoURL);
  out << ", " << "revision=" << to_string(revision);
  out << ", " << "path=" << to_string(path);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


Credentials::~Credentials() throw() {
}


void Credentials::__set_username(const std::string& val) {
  this->username = val;
}

void Credentials::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t Credentials::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_username = false;
  bool isset_password = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          isset_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          isset_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_username)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_password)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Credentials::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Credentials");

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Credentials &a, Credentials &b) {
  using ::std::swap;
  swap(a.username, b.username);
  swap(a.password, b.password);
}

Credentials::Credentials(const Credentials& other3) {
  username = other3.username;
  password = other3.password;
}
Credentials& Credentials::operator=(const Credentials& other4) {
  username = other4.username;
  password = other4.password;
  return *this;
}
void Credentials::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Credentials(";
  out << "username=" << to_string(username);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


DerivedAttributeSpec::~DerivedAttributeSpec() throw() {
}


void DerivedAttributeSpec::__set_metamodelUri(const std::string& val) {
  this->metamodelUri = val;
}

void DerivedAttributeSpec::__set_typeName(const std::string& val) {
  this->typeName = val;
}

void DerivedAttributeSpec::__set_attributeName(const std::string& val) {
  this->attributeName = val;
}

void DerivedAttributeSpec::__set_attributeType(const std::string& val) {
  this->attributeType = val;
__isset.attributeType = true;
}

void DerivedAttributeSpec::__set_isMany(const bool val) {
  this->isMany = val;
__isset.isMany = true;
}

void DerivedAttributeSpec::__set_isOrdered(const bool val) {
  this->isOrdered = val;
__isset.isOrdered = true;
}

void DerivedAttributeSpec::__set_isUnique(const bool val) {
  this->isUnique = val;
__isset.isUnique = true;
}

void DerivedAttributeSpec::__set_derivationLanguage(const std::string& val) {
  this->derivationLanguage = val;
__isset.derivationLanguage = true;
}

void DerivedAttributeSpec::__set_derivationLogic(const std::string& val) {
  this->derivationLogic = val;
__isset.derivationLogic = true;
}

uint32_t DerivedAttributeSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metamodelUri = false;
  bool isset_typeName = false;
  bool isset_attributeName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelUri);
          isset_metamodelUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attributeName);
          isset_attributeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attributeType);
          this->__isset.attributeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMany);
          this->__isset.isMany = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isOrdered);
          this->__isset.isOrdered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isUnique);
          this->__isset.isUnique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->derivationLanguage);
          this->__isset.derivationLanguage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->derivationLogic);
          this->__isset.derivationLogic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metamodelUri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_attributeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DerivedAttributeSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DerivedAttributeSpec");

  xfer += oprot->writeFieldBegin("metamodelUri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->metamodelUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attributeName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributeType) {
    xfer += oprot->writeFieldBegin("attributeType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->attributeType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isMany) {
    xfer += oprot->writeFieldBegin("isMany", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isMany);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isOrdered) {
    xfer += oprot->writeFieldBegin("isOrdered", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isOrdered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isUnique) {
    xfer += oprot->writeFieldBegin("isUnique", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isUnique);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.derivationLanguage) {
    xfer += oprot->writeFieldBegin("derivationLanguage", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->derivationLanguage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.derivationLogic) {
    xfer += oprot->writeFieldBegin("derivationLogic", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->derivationLogic);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DerivedAttributeSpec &a, DerivedAttributeSpec &b) {
  using ::std::swap;
  swap(a.metamodelUri, b.metamodelUri);
  swap(a.typeName, b.typeName);
  swap(a.attributeName, b.attributeName);
  swap(a.attributeType, b.attributeType);
  swap(a.isMany, b.isMany);
  swap(a.isOrdered, b.isOrdered);
  swap(a.isUnique, b.isUnique);
  swap(a.derivationLanguage, b.derivationLanguage);
  swap(a.derivationLogic, b.derivationLogic);
  swap(a.__isset, b.__isset);
}

DerivedAttributeSpec::DerivedAttributeSpec(const DerivedAttributeSpec& other5) {
  metamodelUri = other5.metamodelUri;
  typeName = other5.typeName;
  attributeName = other5.attributeName;
  attributeType = other5.attributeType;
  isMany = other5.isMany;
  isOrdered = other5.isOrdered;
  isUnique = other5.isUnique;
  derivationLanguage = other5.derivationLanguage;
  derivationLogic = other5.derivationLogic;
  __isset = other5.__isset;
}
DerivedAttributeSpec& DerivedAttributeSpec::operator=(const DerivedAttributeSpec& other6) {
  metamodelUri = other6.metamodelUri;
  typeName = other6.typeName;
  attributeName = other6.attributeName;
  attributeType = other6.attributeType;
  isMany = other6.isMany;
  isOrdered = other6.isOrdered;
  isUnique = other6.isUnique;
  derivationLanguage = other6.derivationLanguage;
  derivationLogic = other6.derivationLogic;
  __isset = other6.__isset;
  return *this;
}
void DerivedAttributeSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DerivedAttributeSpec(";
  out << "metamodelUri=" << to_string(metamodelUri);
  out << ", " << "typeName=" << to_string(typeName);
  out << ", " << "attributeName=" << to_string(attributeName);
  out << ", " << "attributeType="; (__isset.attributeType ? (out << to_string(attributeType)) : (out << "<null>"));
  out << ", " << "isMany="; (__isset.isMany ? (out << to_string(isMany)) : (out << "<null>"));
  out << ", " << "isOrdered="; (__isset.isOrdered ? (out << to_string(isOrdered)) : (out << "<null>"));
  out << ", " << "isUnique="; (__isset.isUnique ? (out << to_string(isUnique)) : (out << "<null>"));
  out << ", " << "derivationLanguage="; (__isset.derivationLanguage ? (out << to_string(derivationLanguage)) : (out << "<null>"));
  out << ", " << "derivationLogic="; (__isset.derivationLogic ? (out << to_string(derivationLogic)) : (out << "<null>"));
  out << ")";
}


FailedQuery::~FailedQuery() throw() {
}


void FailedQuery::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t FailedQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FailedQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FailedQuery");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FailedQuery &a, FailedQuery &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

FailedQuery::FailedQuery(const FailedQuery& other7) : TException() {
  reason = other7.reason;
}
FailedQuery& FailedQuery::operator=(const FailedQuery& other8) {
  reason = other8.reason;
  return *this;
}
void FailedQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FailedQuery(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* FailedQuery::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: FailedQuery";
  }
}


File::~File() throw() {
}


void File::__set_name(const std::string& val) {
  this->name = val;
}

void File::__set_contents(const std::string& val) {
  this->contents = val;
}

uint32_t File::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_contents = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->contents);
          isset_contents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_contents)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t File::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("File");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contents", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->contents);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(File &a, File &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.contents, b.contents);
}

File::File(const File& other9) {
  name = other9.name;
  contents = other9.contents;
}
File& File::operator=(const File& other10) {
  name = other10.name;
  contents = other10.contents;
  return *this;
}
void File::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "File(";
  out << "name=" << to_string(name);
  out << ", " << "contents=" << to_string(contents);
  out << ")";
}


HawkFactoryNotFound::~HawkFactoryNotFound() throw() {
}


void HawkFactoryNotFound::__set_factoryName(const std::string& val) {
  this->factoryName = val;
}

uint32_t HawkFactoryNotFound::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_factoryName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->factoryName);
          isset_factoryName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_factoryName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkFactoryNotFound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkFactoryNotFound");

  xfer += oprot->writeFieldBegin("factoryName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->factoryName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkFactoryNotFound &a, HawkFactoryNotFound &b) {
  using ::std::swap;
  swap(a.factoryName, b.factoryName);
}

HawkFactoryNotFound::HawkFactoryNotFound(const HawkFactoryNotFound& other11) : TException() {
  factoryName = other11.factoryName;
}
HawkFactoryNotFound& HawkFactoryNotFound::operator=(const HawkFactoryNotFound& other12) {
  factoryName = other12.factoryName;
  return *this;
}
void HawkFactoryNotFound::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkFactoryNotFound(";
  out << "factoryName=" << to_string(factoryName);
  out << ")";
}

const char* HawkFactoryNotFound::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: HawkFactoryNotFound";
  }
}


HawkInstance::~HawkInstance() throw() {
}


void HawkInstance::__set_name(const std::string& val) {
  this->name = val;
}

void HawkInstance::__set_state(const HawkState::type val) {
  this->state = val;
}

void HawkInstance::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t HawkInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_state = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->state = (HawkState::type)ecast13;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkInstance");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkInstance &a, HawkInstance &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.state, b.state);
  swap(a.message, b.message);
}

HawkInstance::HawkInstance(const HawkInstance& other14) {
  name = other14.name;
  state = other14.state;
  message = other14.message;
}
HawkInstance& HawkInstance::operator=(const HawkInstance& other15) {
  name = other15.name;
  state = other15.state;
  message = other15.message;
  return *this;
}
void HawkInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkInstance(";
  out << "name=" << to_string(name);
  out << ", " << "state=" << to_string(state);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


HawkInstanceNotFound::~HawkInstanceNotFound() throw() {
}


void HawkInstanceNotFound::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

uint32_t HawkInstanceNotFound::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_instanceName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          isset_instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_instanceName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkInstanceNotFound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkInstanceNotFound");

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkInstanceNotFound &a, HawkInstanceNotFound &b) {
  using ::std::swap;
  swap(a.instanceName, b.instanceName);
}

HawkInstanceNotFound::HawkInstanceNotFound(const HawkInstanceNotFound& other16) : TException() {
  instanceName = other16.instanceName;
}
HawkInstanceNotFound& HawkInstanceNotFound::operator=(const HawkInstanceNotFound& other17) {
  instanceName = other17.instanceName;
  return *this;
}
void HawkInstanceNotFound::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkInstanceNotFound(";
  out << "instanceName=" << to_string(instanceName);
  out << ")";
}

const char* HawkInstanceNotFound::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: HawkInstanceNotFound";
  }
}


HawkInstanceNotRunning::~HawkInstanceNotRunning() throw() {
}


void HawkInstanceNotRunning::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

uint32_t HawkInstanceNotRunning::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_instanceName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          isset_instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_instanceName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkInstanceNotRunning::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkInstanceNotRunning");

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkInstanceNotRunning &a, HawkInstanceNotRunning &b) {
  using ::std::swap;
  swap(a.instanceName, b.instanceName);
}

HawkInstanceNotRunning::HawkInstanceNotRunning(const HawkInstanceNotRunning& other18) : TException() {
  instanceName = other18.instanceName;
}
HawkInstanceNotRunning& HawkInstanceNotRunning::operator=(const HawkInstanceNotRunning& other19) {
  instanceName = other19.instanceName;
  return *this;
}
void HawkInstanceNotRunning::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkInstanceNotRunning(";
  out << "instanceName=" << to_string(instanceName);
  out << ")";
}

const char* HawkInstanceNotRunning::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: HawkInstanceNotRunning";
  }
}


HawkMetamodelNotFound::~HawkMetamodelNotFound() throw() {
}


void HawkMetamodelNotFound::__set_metamodelURI(const std::string& val) {
  this->metamodelURI = val;
}

uint32_t HawkMetamodelNotFound::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metamodelURI = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelURI);
          isset_metamodelURI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metamodelURI)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkMetamodelNotFound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkMetamodelNotFound");

  xfer += oprot->writeFieldBegin("metamodelURI", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->metamodelURI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkMetamodelNotFound &a, HawkMetamodelNotFound &b) {
  using ::std::swap;
  swap(a.metamodelURI, b.metamodelURI);
}

HawkMetamodelNotFound::HawkMetamodelNotFound(const HawkMetamodelNotFound& other20) : TException() {
  metamodelURI = other20.metamodelURI;
}
HawkMetamodelNotFound& HawkMetamodelNotFound::operator=(const HawkMetamodelNotFound& other21) {
  metamodelURI = other21.metamodelURI;
  return *this;
}
void HawkMetamodelNotFound::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkMetamodelNotFound(";
  out << "metamodelURI=" << to_string(metamodelURI);
  out << ")";
}

const char* HawkMetamodelNotFound::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: HawkMetamodelNotFound";
  }
}


HawkPlugin::~HawkPlugin() throw() {
}


void HawkPlugin::__set_name(const std::string& val) {
  this->name = val;
}

void HawkPlugin::__set_description(const std::string& val) {
  this->description = val;
}

void HawkPlugin::__set_category(const HawkPluginCategory::type val) {
  this->category = val;
}

uint32_t HawkPlugin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_description = false;
  bool isset_category = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          isset_description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->category = (HawkPluginCategory::type)ecast22;
          isset_category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_description)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_category)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkPlugin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkPlugin");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkPlugin &a, HawkPlugin &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.category, b.category);
}

HawkPlugin::HawkPlugin(const HawkPlugin& other23) {
  name = other23.name;
  description = other23.description;
  category = other23.category;
}
HawkPlugin& HawkPlugin::operator=(const HawkPlugin& other24) {
  name = other24.name;
  description = other24.description;
  category = other24.category;
  return *this;
}
void HawkPlugin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkPlugin(";
  out << "name=" << to_string(name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "category=" << to_string(category);
  out << ")";
}


HawkStateEvent::~HawkStateEvent() throw() {
}


void HawkStateEvent::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void HawkStateEvent::__set_state(const HawkState::type val) {
  this->state = val;
}

void HawkStateEvent::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t HawkStateEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timestamp = false;
  bool isset_state = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->state = (HawkState::type)ecast25;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkStateEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkStateEvent");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkStateEvent &a, HawkStateEvent &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.state, b.state);
  swap(a.message, b.message);
}

HawkStateEvent::HawkStateEvent(const HawkStateEvent& other26) {
  timestamp = other26.timestamp;
  state = other26.state;
  message = other26.message;
}
HawkStateEvent& HawkStateEvent::operator=(const HawkStateEvent& other27) {
  timestamp = other27.timestamp;
  state = other27.state;
  message = other27.message;
  return *this;
}
void HawkStateEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkStateEvent(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "state=" << to_string(state);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


HawkSynchronizationEndEvent::~HawkSynchronizationEndEvent() throw() {
}


void HawkSynchronizationEndEvent::__set_timestampNanos(const int64_t val) {
  this->timestampNanos = val;
}

uint32_t HawkSynchronizationEndEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timestampNanos = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestampNanos);
          isset_timestampNanos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timestampNanos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkSynchronizationEndEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkSynchronizationEndEvent");

  xfer += oprot->writeFieldBegin("timestampNanos", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestampNanos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkSynchronizationEndEvent &a, HawkSynchronizationEndEvent &b) {
  using ::std::swap;
  swap(a.timestampNanos, b.timestampNanos);
}

HawkSynchronizationEndEvent::HawkSynchronizationEndEvent(const HawkSynchronizationEndEvent& other28) {
  timestampNanos = other28.timestampNanos;
}
HawkSynchronizationEndEvent& HawkSynchronizationEndEvent::operator=(const HawkSynchronizationEndEvent& other29) {
  timestampNanos = other29.timestampNanos;
  return *this;
}
void HawkSynchronizationEndEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkSynchronizationEndEvent(";
  out << "timestampNanos=" << to_string(timestampNanos);
  out << ")";
}


HawkSynchronizationStartEvent::~HawkSynchronizationStartEvent() throw() {
}


void HawkSynchronizationStartEvent::__set_timestampNanos(const int64_t val) {
  this->timestampNanos = val;
}

uint32_t HawkSynchronizationStartEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timestampNanos = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestampNanos);
          isset_timestampNanos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timestampNanos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkSynchronizationStartEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkSynchronizationStartEvent");

  xfer += oprot->writeFieldBegin("timestampNanos", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestampNanos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkSynchronizationStartEvent &a, HawkSynchronizationStartEvent &b) {
  using ::std::swap;
  swap(a.timestampNanos, b.timestampNanos);
}

HawkSynchronizationStartEvent::HawkSynchronizationStartEvent(const HawkSynchronizationStartEvent& other30) {
  timestampNanos = other30.timestampNanos;
}
HawkSynchronizationStartEvent& HawkSynchronizationStartEvent::operator=(const HawkSynchronizationStartEvent& other31) {
  timestampNanos = other31.timestampNanos;
  return *this;
}
void HawkSynchronizationStartEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkSynchronizationStartEvent(";
  out << "timestampNanos=" << to_string(timestampNanos);
  out << ")";
}


HawkTypeNotFound::~HawkTypeNotFound() throw() {
}


void HawkTypeNotFound::__set_typeName(const std::string& val) {
  this->typeName = val;
}

uint32_t HawkTypeNotFound::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_typeName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkTypeNotFound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkTypeNotFound");

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkTypeNotFound &a, HawkTypeNotFound &b) {
  using ::std::swap;
  swap(a.typeName, b.typeName);
}

HawkTypeNotFound::HawkTypeNotFound(const HawkTypeNotFound& other32) : TException() {
  typeName = other32.typeName;
}
HawkTypeNotFound& HawkTypeNotFound::operator=(const HawkTypeNotFound& other33) {
  typeName = other33.typeName;
  return *this;
}
void HawkTypeNotFound::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkTypeNotFound(";
  out << "typeName=" << to_string(typeName);
  out << ")";
}

const char* HawkTypeNotFound::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: HawkTypeNotFound";
  }
}


IndexedAttributeSpec::~IndexedAttributeSpec() throw() {
}


void IndexedAttributeSpec::__set_metamodelUri(const std::string& val) {
  this->metamodelUri = val;
}

void IndexedAttributeSpec::__set_typeName(const std::string& val) {
  this->typeName = val;
}

void IndexedAttributeSpec::__set_attributeName(const std::string& val) {
  this->attributeName = val;
}

uint32_t IndexedAttributeSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metamodelUri = false;
  bool isset_typeName = false;
  bool isset_attributeName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelUri);
          isset_metamodelUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attributeName);
          isset_attributeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metamodelUri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_attributeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IndexedAttributeSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexedAttributeSpec");

  xfer += oprot->writeFieldBegin("metamodelUri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->metamodelUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attributeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexedAttributeSpec &a, IndexedAttributeSpec &b) {
  using ::std::swap;
  swap(a.metamodelUri, b.metamodelUri);
  swap(a.typeName, b.typeName);
  swap(a.attributeName, b.attributeName);
}

IndexedAttributeSpec::IndexedAttributeSpec(const IndexedAttributeSpec& other34) {
  metamodelUri = other34.metamodelUri;
  typeName = other34.typeName;
  attributeName = other34.attributeName;
}
IndexedAttributeSpec& IndexedAttributeSpec::operator=(const IndexedAttributeSpec& other35) {
  metamodelUri = other35.metamodelUri;
  typeName = other35.typeName;
  attributeName = other35.attributeName;
  return *this;
}
void IndexedAttributeSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexedAttributeSpec(";
  out << "metamodelUri=" << to_string(metamodelUri);
  out << ", " << "typeName=" << to_string(typeName);
  out << ", " << "attributeName=" << to_string(attributeName);
  out << ")";
}


InvalidDerivedAttributeSpec::~InvalidDerivedAttributeSpec() throw() {
}


void InvalidDerivedAttributeSpec::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidDerivedAttributeSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidDerivedAttributeSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidDerivedAttributeSpec");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidDerivedAttributeSpec &a, InvalidDerivedAttributeSpec &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

InvalidDerivedAttributeSpec::InvalidDerivedAttributeSpec(const InvalidDerivedAttributeSpec& other36) : TException() {
  reason = other36.reason;
}
InvalidDerivedAttributeSpec& InvalidDerivedAttributeSpec::operator=(const InvalidDerivedAttributeSpec& other37) {
  reason = other37.reason;
  return *this;
}
void InvalidDerivedAttributeSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidDerivedAttributeSpec(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* InvalidDerivedAttributeSpec::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidDerivedAttributeSpec";
  }
}


InvalidIndexedAttributeSpec::~InvalidIndexedAttributeSpec() throw() {
}


void InvalidIndexedAttributeSpec::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidIndexedAttributeSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidIndexedAttributeSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidIndexedAttributeSpec");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidIndexedAttributeSpec &a, InvalidIndexedAttributeSpec &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

InvalidIndexedAttributeSpec::InvalidIndexedAttributeSpec(const InvalidIndexedAttributeSpec& other38) : TException() {
  reason = other38.reason;
}
InvalidIndexedAttributeSpec& InvalidIndexedAttributeSpec::operator=(const InvalidIndexedAttributeSpec& other39) {
  reason = other39.reason;
  return *this;
}
void InvalidIndexedAttributeSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidIndexedAttributeSpec(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* InvalidIndexedAttributeSpec::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidIndexedAttributeSpec";
  }
}


InvalidMetamodel::~InvalidMetamodel() throw() {
}


void InvalidMetamodel::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidMetamodel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidMetamodel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidMetamodel");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidMetamodel &a, InvalidMetamodel &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

InvalidMetamodel::InvalidMetamodel(const InvalidMetamodel& other40) : TException() {
  reason = other40.reason;
}
InvalidMetamodel& InvalidMetamodel::operator=(const InvalidMetamodel& other41) {
  reason = other41.reason;
  return *this;
}
void InvalidMetamodel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidMetamodel(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* InvalidMetamodel::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidMetamodel";
  }
}


InvalidPollingConfiguration::~InvalidPollingConfiguration() throw() {
}


void InvalidPollingConfiguration::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidPollingConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidPollingConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidPollingConfiguration");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidPollingConfiguration &a, InvalidPollingConfiguration &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

InvalidPollingConfiguration::InvalidPollingConfiguration(const InvalidPollingConfiguration& other42) : TException() {
  reason = other42.reason;
}
InvalidPollingConfiguration& InvalidPollingConfiguration::operator=(const InvalidPollingConfiguration& other43) {
  reason = other43.reason;
  return *this;
}
void InvalidPollingConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidPollingConfiguration(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* InvalidPollingConfiguration::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidPollingConfiguration";
  }
}


InvalidQuery::~InvalidQuery() throw() {
}


void InvalidQuery::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidQuery");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidQuery &a, InvalidQuery &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
}

InvalidQuery::InvalidQuery(const InvalidQuery& other44) : TException() {
  reason = other44.reason;
}
InvalidQuery& InvalidQuery::operator=(const InvalidQuery& other45) {
  reason = other45.reason;
  return *this;
}
void InvalidQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidQuery(";
  out << "reason=" << to_string(reason);
  out << ")";
}

const char* InvalidQuery::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidQuery";
  }
}


InvalidTransformation::~InvalidTransformation() throw() {
}


void InvalidTransformation::__set_reason(const std::string& val) {
  this->reason = val;
}

void InvalidTransformation::__set_location(const std::string& val) {
  this->location = val;
}

uint32_t InvalidTransformation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reason = false;
  bool isset_location = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidTransformation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidTransformation");

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidTransformation &a, InvalidTransformation &b) {
  using ::std::swap;
  swap(a.reason, b.reason);
  swap(a.location, b.location);
}

InvalidTransformation::InvalidTransformation(const InvalidTransformation& other46) {
  reason = other46.reason;
  location = other46.location;
}
InvalidTransformation& InvalidTransformation::operator=(const InvalidTransformation& other47) {
  reason = other47.reason;
  location = other47.location;
  return *this;
}
void InvalidTransformation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidTransformation(";
  out << "reason=" << to_string(reason);
  out << ", " << "location=" << to_string(location);
  out << ")";
}


MetamodelParserDetails::~MetamodelParserDetails() throw() {
}


void MetamodelParserDetails::__set_fileExtensions(const std::set<std::string> & val) {
  this->fileExtensions = val;
}

void MetamodelParserDetails::__set_identifier(const std::string& val) {
  this->identifier = val;
}

uint32_t MetamodelParserDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileExtensions = false;
  bool isset_identifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->fileExtensions.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readSetBegin(_etype51, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _elem53;
              xfer += iprot->readString(_elem53);
              this->fileExtensions.insert(_elem53);
            }
            xfer += iprot->readSetEnd();
          }
          isset_fileExtensions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifier);
          isset_identifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileExtensions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_identifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MetamodelParserDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetamodelParserDetails");

  xfer += oprot->writeFieldBegin("fileExtensions", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fileExtensions.size()));
    std::set<std::string> ::const_iterator _iter54;
    for (_iter54 = this->fileExtensions.begin(); _iter54 != this->fileExtensions.end(); ++_iter54)
    {
      xfer += oprot->writeString((*_iter54));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->identifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetamodelParserDetails &a, MetamodelParserDetails &b) {
  using ::std::swap;
  swap(a.fileExtensions, b.fileExtensions);
  swap(a.identifier, b.identifier);
}

MetamodelParserDetails::MetamodelParserDetails(const MetamodelParserDetails& other55) {
  fileExtensions = other55.fileExtensions;
  identifier = other55.identifier;
}
MetamodelParserDetails& MetamodelParserDetails::operator=(const MetamodelParserDetails& other56) {
  fileExtensions = other56.fileExtensions;
  identifier = other56.identifier;
  return *this;
}
void MetamodelParserDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetamodelParserDetails(";
  out << "fileExtensions=" << to_string(fileExtensions);
  out << ", " << "identifier=" << to_string(identifier);
  out << ")";
}


MixedReference::~MixedReference() throw() {
}


void MixedReference::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void MixedReference::__set_position(const int32_t val) {
  this->position = val;
__isset.position = true;
}

uint32_t MixedReference::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MixedReference::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MixedReference");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.position) {
    xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->position);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MixedReference &a, MixedReference &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.position, b.position);
  swap(a.__isset, b.__isset);
}

MixedReference::MixedReference(const MixedReference& other57) {
  id = other57.id;
  position = other57.position;
  __isset = other57.__isset;
}
MixedReference& MixedReference::operator=(const MixedReference& other58) {
  id = other58.id;
  position = other58.position;
  __isset = other58.__isset;
  return *this;
}
void MixedReference::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MixedReference(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "position="; (__isset.position ? (out << to_string(position)) : (out << "<null>"));
  out << ")";
}


ModelSpec::~ModelSpec() throw() {
}


void ModelSpec::__set_uri(const std::string& val) {
  this->uri = val;
}

void ModelSpec::__set_metamodelUris(const std::vector<std::string> & val) {
  this->metamodelUris = val;
}

uint32_t ModelSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uri = false;
  bool isset_metamodelUris = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          isset_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metamodelUris.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->metamodelUris.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readString(this->metamodelUris[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          isset_metamodelUris = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metamodelUris)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ModelSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelSpec");

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metamodelUris", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metamodelUris.size()));
    std::vector<std::string> ::const_iterator _iter64;
    for (_iter64 = this->metamodelUris.begin(); _iter64 != this->metamodelUris.end(); ++_iter64)
    {
      xfer += oprot->writeString((*_iter64));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelSpec &a, ModelSpec &b) {
  using ::std::swap;
  swap(a.uri, b.uri);
  swap(a.metamodelUris, b.metamodelUris);
}

ModelSpec::ModelSpec(const ModelSpec& other65) {
  uri = other65.uri;
  metamodelUris = other65.metamodelUris;
}
ModelSpec& ModelSpec::operator=(const ModelSpec& other66) {
  uri = other66.uri;
  metamodelUris = other66.metamodelUris;
  return *this;
}
void ModelSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelSpec(";
  out << "uri=" << to_string(uri);
  out << ", " << "metamodelUris=" << to_string(metamodelUris);
  out << ")";
}


Repository::~Repository() throw() {
}


void Repository::__set_uri(const std::string& val) {
  this->uri = val;
}

void Repository::__set_type(const std::string& val) {
  this->type = val;
}

void Repository::__set_isFrozen(const bool val) {
  this->isFrozen = val;
__isset.isFrozen = true;
}

uint32_t Repository::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uri = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          isset_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFrozen);
          this->__isset.isFrozen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Repository::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Repository");

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isFrozen) {
    xfer += oprot->writeFieldBegin("isFrozen", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isFrozen);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Repository &a, Repository &b) {
  using ::std::swap;
  swap(a.uri, b.uri);
  swap(a.type, b.type);
  swap(a.isFrozen, b.isFrozen);
  swap(a.__isset, b.__isset);
}

Repository::Repository(const Repository& other67) {
  uri = other67.uri;
  type = other67.type;
  isFrozen = other67.isFrozen;
  __isset = other67.__isset;
}
Repository& Repository::operator=(const Repository& other68) {
  uri = other68.uri;
  type = other68.type;
  isFrozen = other68.isFrozen;
  __isset = other68.__isset;
  return *this;
}
void Repository::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Repository(";
  out << "uri=" << to_string(uri);
  out << ", " << "type=" << to_string(type);
  out << ", " << "isFrozen="; (__isset.isFrozen ? (out << to_string(isFrozen)) : (out << "<null>"));
  out << ")";
}


Slot::~Slot() throw() {
}


void Slot::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t Slot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Slot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Slot");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Slot &a, Slot &b) {
  using ::std::swap;
  swap(a.name, b.name);
}

Slot::Slot(const Slot& other69) {
  name = other69.name;
}
Slot& Slot::operator=(const Slot& other70) {
  name = other70.name;
  return *this;
}
void Slot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Slot(";
  out << "name=" << to_string(name);
  out << ")";
}


SlotMetadata::~SlotMetadata() throw() {
}


void SlotMetadata::__set_name(const std::string& val) {
  this->name = val;
}

void SlotMetadata::__set_type(const std::string& val) {
  this->type = val;
}

void SlotMetadata::__set_isMany(const bool val) {
  this->isMany = val;
}

void SlotMetadata::__set_isOrdered(const bool val) {
  this->isOrdered = val;
}

void SlotMetadata::__set_isUnique(const bool val) {
  this->isUnique = val;
}

uint32_t SlotMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_isMany = false;
  bool isset_isOrdered = false;
  bool isset_isUnique = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMany);
          isset_isMany = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isOrdered);
          isset_isOrdered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isUnique);
          isset_isUnique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isMany)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isOrdered)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isUnique)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SlotMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SlotMetadata");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMany", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isMany);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isOrdered", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->isOrdered);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isUnique", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isUnique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SlotMetadata &a, SlotMetadata &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.isMany, b.isMany);
  swap(a.isOrdered, b.isOrdered);
  swap(a.isUnique, b.isUnique);
}

SlotMetadata::SlotMetadata(const SlotMetadata& other71) {
  name = other71.name;
  type = other71.type;
  isMany = other71.isMany;
  isOrdered = other71.isOrdered;
  isUnique = other71.isUnique;
}
SlotMetadata& SlotMetadata::operator=(const SlotMetadata& other72) {
  name = other72.name;
  type = other72.type;
  isMany = other72.isMany;
  isOrdered = other72.isOrdered;
  isUnique = other72.isUnique;
  return *this;
}
void SlotMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SlotMetadata(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "isMany=" << to_string(isMany);
  out << ", " << "isOrdered=" << to_string(isOrdered);
  out << ", " << "isUnique=" << to_string(isUnique);
  out << ")";
}


SlotValue::~SlotValue() throw() {
}


void SlotValue::__set_vBoolean(const bool val) {
  this->vBoolean = val;
__isset.vBoolean = true;
}

void SlotValue::__set_vByte(const int8_t val) {
  this->vByte = val;
__isset.vByte = true;
}

void SlotValue::__set_vShort(const int16_t val) {
  this->vShort = val;
__isset.vShort = true;
}

void SlotValue::__set_vInteger(const int32_t val) {
  this->vInteger = val;
__isset.vInteger = true;
}

void SlotValue::__set_vLong(const int64_t val) {
  this->vLong = val;
__isset.vLong = true;
}

void SlotValue::__set_vDouble(const double val) {
  this->vDouble = val;
__isset.vDouble = true;
}

void SlotValue::__set_vString(const std::string& val) {
  this->vString = val;
__isset.vString = true;
}

void SlotValue::__set_vBooleans(const std::vector<bool> & val) {
  this->vBooleans = val;
__isset.vBooleans = true;
}

void SlotValue::__set_vBytes(const std::string& val) {
  this->vBytes = val;
__isset.vBytes = true;
}

void SlotValue::__set_vShorts(const std::vector<int16_t> & val) {
  this->vShorts = val;
__isset.vShorts = true;
}

void SlotValue::__set_vIntegers(const std::vector<int32_t> & val) {
  this->vIntegers = val;
__isset.vIntegers = true;
}

void SlotValue::__set_vLongs(const std::vector<int64_t> & val) {
  this->vLongs = val;
__isset.vLongs = true;
}

void SlotValue::__set_vDoubles(const std::vector<double> & val) {
  this->vDoubles = val;
__isset.vDoubles = true;
}

void SlotValue::__set_vStrings(const std::vector<std::string> & val) {
  this->vStrings = val;
__isset.vStrings = true;
}

void SlotValue::__set_vLists(const std::vector<SlotValue> & val) {
  this->vLists = val;
__isset.vLists = true;
}

uint32_t SlotValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->vBoolean);
          this->__isset.vBoolean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->vByte);
          this->__isset.vByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->vShort);
          this->__isset.vShort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vInteger);
          this->__isset.vInteger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vLong);
          this->__isset.vLong = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vDouble);
          this->__isset.vDouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vString);
          this->__isset.vString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vBooleans.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->vBooleans.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readBool(this->vBooleans[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vBooleans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->vBytes);
          this->__isset.vBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vShorts.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->vShorts.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += iprot->readI16(this->vShorts[_i82]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vShorts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vIntegers.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->vIntegers.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readI32(this->vIntegers[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vIntegers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vLongs.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->vLongs.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += iprot->readI64(this->vLongs[_i92]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vLongs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vDoubles.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->vDoubles.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readDouble(this->vDoubles[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vDoubles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vStrings.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->vStrings.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += iprot->readString(this->vStrings[_i102]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vStrings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vLists.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->vLists.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += this->vLists[_i107].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vLists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SlotValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SlotValue");

  if (this->__isset.vBoolean) {
    xfer += oprot->writeFieldBegin("vBoolean", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->vBoolean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vByte) {
    xfer += oprot->writeFieldBegin("vByte", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->vByte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vShort) {
    xfer += oprot->writeFieldBegin("vShort", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->vShort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vInteger) {
    xfer += oprot->writeFieldBegin("vInteger", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->vInteger);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vLong) {
    xfer += oprot->writeFieldBegin("vLong", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->vLong);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vDouble) {
    xfer += oprot->writeFieldBegin("vDouble", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->vDouble);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vString) {
    xfer += oprot->writeFieldBegin("vString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->vString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vBooleans) {
    xfer += oprot->writeFieldBegin("vBooleans", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->vBooleans.size()));
      std::vector<bool> ::const_iterator _iter108;
      for (_iter108 = this->vBooleans.begin(); _iter108 != this->vBooleans.end(); ++_iter108)
      {
        xfer += oprot->writeBool((*_iter108));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vBytes) {
    xfer += oprot->writeFieldBegin("vBytes", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeBinary(this->vBytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vShorts) {
    xfer += oprot->writeFieldBegin("vShorts", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->vShorts.size()));
      std::vector<int16_t> ::const_iterator _iter109;
      for (_iter109 = this->vShorts.begin(); _iter109 != this->vShorts.end(); ++_iter109)
      {
        xfer += oprot->writeI16((*_iter109));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vIntegers) {
    xfer += oprot->writeFieldBegin("vIntegers", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->vIntegers.size()));
      std::vector<int32_t> ::const_iterator _iter110;
      for (_iter110 = this->vIntegers.begin(); _iter110 != this->vIntegers.end(); ++_iter110)
      {
        xfer += oprot->writeI32((*_iter110));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vLongs) {
    xfer += oprot->writeFieldBegin("vLongs", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->vLongs.size()));
      std::vector<int64_t> ::const_iterator _iter111;
      for (_iter111 = this->vLongs.begin(); _iter111 != this->vLongs.end(); ++_iter111)
      {
        xfer += oprot->writeI64((*_iter111));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vDoubles) {
    xfer += oprot->writeFieldBegin("vDoubles", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->vDoubles.size()));
      std::vector<double> ::const_iterator _iter112;
      for (_iter112 = this->vDoubles.begin(); _iter112 != this->vDoubles.end(); ++_iter112)
      {
        xfer += oprot->writeDouble((*_iter112));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vStrings) {
    xfer += oprot->writeFieldBegin("vStrings", ::apache::thrift::protocol::T_LIST, 14);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vStrings.size()));
      std::vector<std::string> ::const_iterator _iter113;
      for (_iter113 = this->vStrings.begin(); _iter113 != this->vStrings.end(); ++_iter113)
      {
        xfer += oprot->writeString((*_iter113));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vLists) {
    xfer += oprot->writeFieldBegin("vLists", ::apache::thrift::protocol::T_LIST, 15);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vLists.size()));
      std::vector<SlotValue> ::const_iterator _iter114;
      for (_iter114 = this->vLists.begin(); _iter114 != this->vLists.end(); ++_iter114)
      {
        xfer += (*_iter114).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SlotValue &a, SlotValue &b) {
  using ::std::swap;
  swap(a.vBoolean, b.vBoolean);
  swap(a.vByte, b.vByte);
  swap(a.vShort, b.vShort);
  swap(a.vInteger, b.vInteger);
  swap(a.vLong, b.vLong);
  swap(a.vDouble, b.vDouble);
  swap(a.vString, b.vString);
  swap(a.vBooleans, b.vBooleans);
  swap(a.vBytes, b.vBytes);
  swap(a.vShorts, b.vShorts);
  swap(a.vIntegers, b.vIntegers);
  swap(a.vLongs, b.vLongs);
  swap(a.vDoubles, b.vDoubles);
  swap(a.vStrings, b.vStrings);
  swap(a.vLists, b.vLists);
  swap(a.__isset, b.__isset);
}

SlotValue::SlotValue(const SlotValue& other115) {
  vBoolean = other115.vBoolean;
  vByte = other115.vByte;
  vShort = other115.vShort;
  vInteger = other115.vInteger;
  vLong = other115.vLong;
  vDouble = other115.vDouble;
  vString = other115.vString;
  vBooleans = other115.vBooleans;
  vBytes = other115.vBytes;
  vShorts = other115.vShorts;
  vIntegers = other115.vIntegers;
  vLongs = other115.vLongs;
  vDoubles = other115.vDoubles;
  vStrings = other115.vStrings;
  vLists = other115.vLists;
  __isset = other115.__isset;
}
SlotValue& SlotValue::operator=(const SlotValue& other116) {
  vBoolean = other116.vBoolean;
  vByte = other116.vByte;
  vShort = other116.vShort;
  vInteger = other116.vInteger;
  vLong = other116.vLong;
  vDouble = other116.vDouble;
  vString = other116.vString;
  vBooleans = other116.vBooleans;
  vBytes = other116.vBytes;
  vShorts = other116.vShorts;
  vIntegers = other116.vIntegers;
  vLongs = other116.vLongs;
  vDoubles = other116.vDoubles;
  vStrings = other116.vStrings;
  vLists = other116.vLists;
  __isset = other116.__isset;
  return *this;
}
void SlotValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SlotValue(";
  out << "vBoolean="; (__isset.vBoolean ? (out << to_string(vBoolean)) : (out << "<null>"));
  out << ", " << "vByte="; (__isset.vByte ? (out << to_string(vByte)) : (out << "<null>"));
  out << ", " << "vShort="; (__isset.vShort ? (out << to_string(vShort)) : (out << "<null>"));
  out << ", " << "vInteger="; (__isset.vInteger ? (out << to_string(vInteger)) : (out << "<null>"));
  out << ", " << "vLong="; (__isset.vLong ? (out << to_string(vLong)) : (out << "<null>"));
  out << ", " << "vDouble="; (__isset.vDouble ? (out << to_string(vDouble)) : (out << "<null>"));
  out << ", " << "vString="; (__isset.vString ? (out << to_string(vString)) : (out << "<null>"));
  out << ", " << "vBooleans="; (__isset.vBooleans ? (out << to_string(vBooleans)) : (out << "<null>"));
  out << ", " << "vBytes="; (__isset.vBytes ? (out << to_string(vBytes)) : (out << "<null>"));
  out << ", " << "vShorts="; (__isset.vShorts ? (out << to_string(vShorts)) : (out << "<null>"));
  out << ", " << "vIntegers="; (__isset.vIntegers ? (out << to_string(vIntegers)) : (out << "<null>"));
  out << ", " << "vLongs="; (__isset.vLongs ? (out << to_string(vLongs)) : (out << "<null>"));
  out << ", " << "vDoubles="; (__isset.vDoubles ? (out << to_string(vDoubles)) : (out << "<null>"));
  out << ", " << "vStrings="; (__isset.vStrings ? (out << to_string(vStrings)) : (out << "<null>"));
  out << ", " << "vLists="; (__isset.vLists ? (out << to_string(vLists)) : (out << "<null>"));
  out << ")";
}


Subscription::~Subscription() throw() {
}


void Subscription::__set_host(const std::string& val) {
  this->host = val;
}

void Subscription::__set_port(const int32_t val) {
  this->port = val;
}

void Subscription::__set_queueAddress(const std::string& val) {
  this->queueAddress = val;
}

void Subscription::__set_queueName(const std::string& val) {
  this->queueName = val;
}

void Subscription::__set_sslRequired(const bool val) {
  this->sslRequired = val;
}

uint32_t Subscription::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_queueAddress = false;
  bool isset_queueName = false;
  bool isset_sslRequired = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueAddress);
          isset_queueAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueName);
          isset_queueName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sslRequired);
          isset_sslRequired = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queueAddress)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queueName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sslRequired)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Subscription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Subscription");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueAddress", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->queueAddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->queueName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sslRequired", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->sslRequired);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Subscription &a, Subscription &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.queueAddress, b.queueAddress);
  swap(a.queueName, b.queueName);
  swap(a.sslRequired, b.sslRequired);
}

Subscription::Subscription(const Subscription& other117) {
  host = other117.host;
  port = other117.port;
  queueAddress = other117.queueAddress;
  queueName = other117.queueName;
  sslRequired = other117.sslRequired;
}
Subscription& Subscription::operator=(const Subscription& other118) {
  host = other118.host;
  port = other118.port;
  queueAddress = other118.queueAddress;
  queueName = other118.queueName;
  sslRequired = other118.sslRequired;
  return *this;
}
void Subscription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Subscription(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "queueAddress=" << to_string(queueAddress);
  out << ", " << "queueName=" << to_string(queueName);
  out << ", " << "sslRequired=" << to_string(sslRequired);
  out << ")";
}


UnknownQueryLanguage::~UnknownQueryLanguage() throw() {
}


void UnknownQueryLanguage::__set_queryLanguage(const std::string& val) {
  this->queryLanguage = val;
}

uint32_t UnknownQueryLanguage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_queryLanguage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queryLanguage);
          isset_queryLanguage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_queryLanguage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnknownQueryLanguage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownQueryLanguage");

  xfer += oprot->writeFieldBegin("queryLanguage", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->queryLanguage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownQueryLanguage &a, UnknownQueryLanguage &b) {
  using ::std::swap;
  swap(a.queryLanguage, b.queryLanguage);
}

UnknownQueryLanguage::UnknownQueryLanguage(const UnknownQueryLanguage& other119) : TException() {
  queryLanguage = other119.queryLanguage;
}
UnknownQueryLanguage& UnknownQueryLanguage::operator=(const UnknownQueryLanguage& other120) {
  queryLanguage = other120.queryLanguage;
  return *this;
}
void UnknownQueryLanguage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownQueryLanguage(";
  out << "queryLanguage=" << to_string(queryLanguage);
  out << ")";
}

const char* UnknownQueryLanguage::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownQueryLanguage";
  }
}


UnknownRepositoryType::~UnknownRepositoryType() throw() {
}


void UnknownRepositoryType::__set_repositoryType(const std::string& val) {
  this->repositoryType = val;
}

uint32_t UnknownRepositoryType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_repositoryType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repositoryType);
          isset_repositoryType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_repositoryType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnknownRepositoryType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownRepositoryType");

  xfer += oprot->writeFieldBegin("repositoryType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->repositoryType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownRepositoryType &a, UnknownRepositoryType &b) {
  using ::std::swap;
  swap(a.repositoryType, b.repositoryType);
}

UnknownRepositoryType::UnknownRepositoryType(const UnknownRepositoryType& other121) : TException() {
  repositoryType = other121.repositoryType;
}
UnknownRepositoryType& UnknownRepositoryType::operator=(const UnknownRepositoryType& other122) {
  repositoryType = other122.repositoryType;
  return *this;
}
void UnknownRepositoryType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownRepositoryType(";
  out << "repositoryType=" << to_string(repositoryType);
  out << ")";
}

const char* UnknownRepositoryType::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownRepositoryType";
  }
}


UserExists::~UserExists() throw() {
}


uint32_t UserExists::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserExists::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserExists");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserExists &a, UserExists &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

UserExists::UserExists(const UserExists& other123) : TException() {
  (void) other123;
}
UserExists& UserExists::operator=(const UserExists& other124) {
  (void) other124;
  return *this;
}
void UserExists::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserExists(";
  out << ")";
}

const char* UserExists::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UserExists";
  }
}


UserNotFound::~UserNotFound() throw() {
}


uint32_t UserNotFound::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserNotFound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserNotFound");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserNotFound &a, UserNotFound &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

UserNotFound::UserNotFound(const UserNotFound& other125) : TException() {
  (void) other125;
}
UserNotFound& UserNotFound::operator=(const UserNotFound& other126) {
  (void) other126;
  return *this;
}
void UserNotFound::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserNotFound(";
  out << ")";
}

const char* UserNotFound::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UserNotFound";
  }
}


UserProfile::~UserProfile() throw() {
}


void UserProfile::__set_realName(const std::string& val) {
  this->realName = val;
}

void UserProfile::__set_admin(const bool val) {
  this->admin = val;
}

uint32_t UserProfile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_realName = false;
  bool isset_admin = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->realName);
          isset_realName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->admin);
          isset_admin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_realName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_admin)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserProfile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserProfile");

  xfer += oprot->writeFieldBegin("realName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->realName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("admin", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->admin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserProfile &a, UserProfile &b) {
  using ::std::swap;
  swap(a.realName, b.realName);
  swap(a.admin, b.admin);
}

UserProfile::UserProfile(const UserProfile& other127) {
  realName = other127.realName;
  admin = other127.admin;
}
UserProfile& UserProfile::operator=(const UserProfile& other128) {
  realName = other128.realName;
  admin = other128.admin;
  return *this;
}
void UserProfile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserProfile(";
  out << "realName=" << to_string(realName);
  out << ", " << "admin=" << to_string(admin);
  out << ")";
}


VCSAuthenticationFailed::~VCSAuthenticationFailed() throw() {
}


uint32_t VCSAuthenticationFailed::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VCSAuthenticationFailed::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VCSAuthenticationFailed");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VCSAuthenticationFailed &a, VCSAuthenticationFailed &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

VCSAuthenticationFailed::VCSAuthenticationFailed(const VCSAuthenticationFailed& other129) : TException() {
  (void) other129;
}
VCSAuthenticationFailed& VCSAuthenticationFailed::operator=(const VCSAuthenticationFailed& other130) {
  (void) other130;
  return *this;
}
void VCSAuthenticationFailed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VCSAuthenticationFailed(";
  out << ")";
}

const char* VCSAuthenticationFailed::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: VCSAuthenticationFailed";
  }
}


Value::~Value() throw() {
}


void Value::__set_vBoolean(const bool val) {
  this->vBoolean = val;
__isset.vBoolean = true;
}

void Value::__set_vByte(const int8_t val) {
  this->vByte = val;
__isset.vByte = true;
}

void Value::__set_vShort(const int16_t val) {
  this->vShort = val;
__isset.vShort = true;
}

void Value::__set_vInteger(const int32_t val) {
  this->vInteger = val;
__isset.vInteger = true;
}

void Value::__set_vLong(const int64_t val) {
  this->vLong = val;
__isset.vLong = true;
}

void Value::__set_vDouble(const double val) {
  this->vDouble = val;
__isset.vDouble = true;
}

void Value::__set_vString(const std::string& val) {
  this->vString = val;
__isset.vString = true;
}

uint32_t Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->vBoolean);
          this->__isset.vBoolean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->vByte);
          this->__isset.vByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->vShort);
          this->__isset.vShort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vInteger);
          this->__isset.vInteger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vLong);
          this->__isset.vLong = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vDouble);
          this->__isset.vDouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vString);
          this->__isset.vString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Value");

  if (this->__isset.vBoolean) {
    xfer += oprot->writeFieldBegin("vBoolean", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->vBoolean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vByte) {
    xfer += oprot->writeFieldBegin("vByte", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->vByte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vShort) {
    xfer += oprot->writeFieldBegin("vShort", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->vShort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vInteger) {
    xfer += oprot->writeFieldBegin("vInteger", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->vInteger);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vLong) {
    xfer += oprot->writeFieldBegin("vLong", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->vLong);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vDouble) {
    xfer += oprot->writeFieldBegin("vDouble", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->vDouble);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vString) {
    xfer += oprot->writeFieldBegin("vString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->vString);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Value &a, Value &b) {
  using ::std::swap;
  swap(a.vBoolean, b.vBoolean);
  swap(a.vByte, b.vByte);
  swap(a.vShort, b.vShort);
  swap(a.vInteger, b.vInteger);
  swap(a.vLong, b.vLong);
  swap(a.vDouble, b.vDouble);
  swap(a.vString, b.vString);
  swap(a.__isset, b.__isset);
}

Value::Value(const Value& other131) {
  vBoolean = other131.vBoolean;
  vByte = other131.vByte;
  vShort = other131.vShort;
  vInteger = other131.vInteger;
  vLong = other131.vLong;
  vDouble = other131.vDouble;
  vString = other131.vString;
  __isset = other131.__isset;
}
Value& Value::operator=(const Value& other132) {
  vBoolean = other132.vBoolean;
  vByte = other132.vByte;
  vShort = other132.vShort;
  vInteger = other132.vInteger;
  vLong = other132.vLong;
  vDouble = other132.vDouble;
  vString = other132.vString;
  __isset = other132.__isset;
  return *this;
}
void Value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Value(";
  out << "vBoolean="; (__isset.vBoolean ? (out << to_string(vBoolean)) : (out << "<null>"));
  out << ", " << "vByte="; (__isset.vByte ? (out << to_string(vByte)) : (out << "<null>"));
  out << ", " << "vShort="; (__isset.vShort ? (out << to_string(vShort)) : (out << "<null>"));
  out << ", " << "vInteger="; (__isset.vInteger ? (out << to_string(vInteger)) : (out << "<null>"));
  out << ", " << "vLong="; (__isset.vLong ? (out << to_string(vLong)) : (out << "<null>"));
  out << ", " << "vDouble="; (__isset.vDouble ? (out << to_string(vDouble)) : (out << "<null>"));
  out << ", " << "vString="; (__isset.vString ? (out << to_string(vString)) : (out << "<null>"));
  out << ")";
}


AttributeSlot::~AttributeSlot() throw() {
}


void AttributeSlot::__set_name(const std::string& val) {
  this->name = val;
}

void AttributeSlot::__set_value(const SlotValue& val) {
  this->value = val;
__isset.value = true;
}

uint32_t AttributeSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AttributeSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AttributeSlot");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttributeSlot &a, AttributeSlot &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

AttributeSlot::AttributeSlot(const AttributeSlot& other133) {
  name = other133.name;
  value = other133.value;
  __isset = other133.__isset;
}
AttributeSlot& AttributeSlot::operator=(const AttributeSlot& other134) {
  name = other134.name;
  value = other134.value;
  __isset = other134.__isset;
  return *this;
}
void AttributeSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AttributeSlot(";
  out << "name=" << to_string(name);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


HawkAttributeRemovalEvent::~HawkAttributeRemovalEvent() throw() {
}


void HawkAttributeRemovalEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkAttributeRemovalEvent::__set_id(const std::string& val) {
  this->id = val;
}

void HawkAttributeRemovalEvent::__set_attribute(const std::string& val) {
  this->attribute = val;
}

uint32_t HawkAttributeRemovalEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_id = false;
  bool isset_attribute = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attribute);
          isset_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_attribute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkAttributeRemovalEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkAttributeRemovalEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attribute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkAttributeRemovalEvent &a, HawkAttributeRemovalEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.id, b.id);
  swap(a.attribute, b.attribute);
}

HawkAttributeRemovalEvent::HawkAttributeRemovalEvent(const HawkAttributeRemovalEvent& other135) {
  vcsItem = other135.vcsItem;
  id = other135.id;
  attribute = other135.attribute;
}
HawkAttributeRemovalEvent& HawkAttributeRemovalEvent::operator=(const HawkAttributeRemovalEvent& other136) {
  vcsItem = other136.vcsItem;
  id = other136.id;
  attribute = other136.attribute;
  return *this;
}
void HawkAttributeRemovalEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkAttributeRemovalEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "id=" << to_string(id);
  out << ", " << "attribute=" << to_string(attribute);
  out << ")";
}


HawkAttributeUpdateEvent::~HawkAttributeUpdateEvent() throw() {
}


void HawkAttributeUpdateEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkAttributeUpdateEvent::__set_id(const std::string& val) {
  this->id = val;
}

void HawkAttributeUpdateEvent::__set_attribute(const std::string& val) {
  this->attribute = val;
}

void HawkAttributeUpdateEvent::__set_value(const SlotValue& val) {
  this->value = val;
}

uint32_t HawkAttributeUpdateEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_id = false;
  bool isset_attribute = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attribute);
          isset_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_attribute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkAttributeUpdateEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkAttributeUpdateEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->attribute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkAttributeUpdateEvent &a, HawkAttributeUpdateEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.id, b.id);
  swap(a.attribute, b.attribute);
  swap(a.value, b.value);
}

HawkAttributeUpdateEvent::HawkAttributeUpdateEvent(const HawkAttributeUpdateEvent& other137) {
  vcsItem = other137.vcsItem;
  id = other137.id;
  attribute = other137.attribute;
  value = other137.value;
}
HawkAttributeUpdateEvent& HawkAttributeUpdateEvent::operator=(const HawkAttributeUpdateEvent& other138) {
  vcsItem = other138.vcsItem;
  id = other138.id;
  attribute = other138.attribute;
  value = other138.value;
  return *this;
}
void HawkAttributeUpdateEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkAttributeUpdateEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "id=" << to_string(id);
  out << ", " << "attribute=" << to_string(attribute);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


HawkFileAdditionEvent::~HawkFileAdditionEvent() throw() {
}


void HawkFileAdditionEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

uint32_t HawkFileAdditionEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkFileAdditionEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkFileAdditionEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkFileAdditionEvent &a, HawkFileAdditionEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
}

HawkFileAdditionEvent::HawkFileAdditionEvent(const HawkFileAdditionEvent& other139) {
  vcsItem = other139.vcsItem;
}
HawkFileAdditionEvent& HawkFileAdditionEvent::operator=(const HawkFileAdditionEvent& other140) {
  vcsItem = other140.vcsItem;
  return *this;
}
void HawkFileAdditionEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkFileAdditionEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ")";
}


HawkFileRemovalEvent::~HawkFileRemovalEvent() throw() {
}


void HawkFileRemovalEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

uint32_t HawkFileRemovalEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkFileRemovalEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkFileRemovalEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkFileRemovalEvent &a, HawkFileRemovalEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
}

HawkFileRemovalEvent::HawkFileRemovalEvent(const HawkFileRemovalEvent& other141) {
  vcsItem = other141.vcsItem;
}
HawkFileRemovalEvent& HawkFileRemovalEvent::operator=(const HawkFileRemovalEvent& other142) {
  vcsItem = other142.vcsItem;
  return *this;
}
void HawkFileRemovalEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkFileRemovalEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ")";
}


HawkModelElementAdditionEvent::~HawkModelElementAdditionEvent() throw() {
}


void HawkModelElementAdditionEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkModelElementAdditionEvent::__set_metamodelURI(const std::string& val) {
  this->metamodelURI = val;
}

void HawkModelElementAdditionEvent::__set_typeName(const std::string& val) {
  this->typeName = val;
}

void HawkModelElementAdditionEvent::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t HawkModelElementAdditionEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_metamodelURI = false;
  bool isset_typeName = false;
  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelURI);
          isset_metamodelURI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metamodelURI)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkModelElementAdditionEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkModelElementAdditionEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metamodelURI", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->metamodelURI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkModelElementAdditionEvent &a, HawkModelElementAdditionEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.metamodelURI, b.metamodelURI);
  swap(a.typeName, b.typeName);
  swap(a.id, b.id);
}

HawkModelElementAdditionEvent::HawkModelElementAdditionEvent(const HawkModelElementAdditionEvent& other143) {
  vcsItem = other143.vcsItem;
  metamodelURI = other143.metamodelURI;
  typeName = other143.typeName;
  id = other143.id;
}
HawkModelElementAdditionEvent& HawkModelElementAdditionEvent::operator=(const HawkModelElementAdditionEvent& other144) {
  vcsItem = other144.vcsItem;
  metamodelURI = other144.metamodelURI;
  typeName = other144.typeName;
  id = other144.id;
  return *this;
}
void HawkModelElementAdditionEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkModelElementAdditionEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "metamodelURI=" << to_string(metamodelURI);
  out << ", " << "typeName=" << to_string(typeName);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


HawkModelElementRemovalEvent::~HawkModelElementRemovalEvent() throw() {
}


void HawkModelElementRemovalEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkModelElementRemovalEvent::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t HawkModelElementRemovalEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkModelElementRemovalEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkModelElementRemovalEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkModelElementRemovalEvent &a, HawkModelElementRemovalEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.id, b.id);
}

HawkModelElementRemovalEvent::HawkModelElementRemovalEvent(const HawkModelElementRemovalEvent& other145) {
  vcsItem = other145.vcsItem;
  id = other145.id;
}
HawkModelElementRemovalEvent& HawkModelElementRemovalEvent::operator=(const HawkModelElementRemovalEvent& other146) {
  vcsItem = other146.vcsItem;
  id = other146.id;
  return *this;
}
void HawkModelElementRemovalEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkModelElementRemovalEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


HawkReferenceAdditionEvent::~HawkReferenceAdditionEvent() throw() {
}


void HawkReferenceAdditionEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkReferenceAdditionEvent::__set_sourceId(const std::string& val) {
  this->sourceId = val;
}

void HawkReferenceAdditionEvent::__set_targetId(const std::string& val) {
  this->targetId = val;
}

void HawkReferenceAdditionEvent::__set_refName(const std::string& val) {
  this->refName = val;
}

uint32_t HawkReferenceAdditionEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_sourceId = false;
  bool isset_targetId = false;
  bool isset_refName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceId);
          isset_sourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetId);
          isset_targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->refName);
          isset_refName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targetId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_refName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkReferenceAdditionEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkReferenceAdditionEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->refName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkReferenceAdditionEvent &a, HawkReferenceAdditionEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.sourceId, b.sourceId);
  swap(a.targetId, b.targetId);
  swap(a.refName, b.refName);
}

HawkReferenceAdditionEvent::HawkReferenceAdditionEvent(const HawkReferenceAdditionEvent& other147) {
  vcsItem = other147.vcsItem;
  sourceId = other147.sourceId;
  targetId = other147.targetId;
  refName = other147.refName;
}
HawkReferenceAdditionEvent& HawkReferenceAdditionEvent::operator=(const HawkReferenceAdditionEvent& other148) {
  vcsItem = other148.vcsItem;
  sourceId = other148.sourceId;
  targetId = other148.targetId;
  refName = other148.refName;
  return *this;
}
void HawkReferenceAdditionEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkReferenceAdditionEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "sourceId=" << to_string(sourceId);
  out << ", " << "targetId=" << to_string(targetId);
  out << ", " << "refName=" << to_string(refName);
  out << ")";
}


HawkReferenceRemovalEvent::~HawkReferenceRemovalEvent() throw() {
}


void HawkReferenceRemovalEvent::__set_vcsItem(const CommitItem& val) {
  this->vcsItem = val;
}

void HawkReferenceRemovalEvent::__set_sourceId(const std::string& val) {
  this->sourceId = val;
}

void HawkReferenceRemovalEvent::__set_targetId(const std::string& val) {
  this->targetId = val;
}

void HawkReferenceRemovalEvent::__set_refName(const std::string& val) {
  this->refName = val;
}

uint32_t HawkReferenceRemovalEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vcsItem = false;
  bool isset_sourceId = false;
  bool isset_targetId = false;
  bool isset_refName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vcsItem.read(iprot);
          isset_vcsItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceId);
          isset_sourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetId);
          isset_targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->refName);
          isset_refName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vcsItem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targetId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_refName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HawkReferenceRemovalEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkReferenceRemovalEvent");

  xfer += oprot->writeFieldBegin("vcsItem", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->vcsItem.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->refName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkReferenceRemovalEvent &a, HawkReferenceRemovalEvent &b) {
  using ::std::swap;
  swap(a.vcsItem, b.vcsItem);
  swap(a.sourceId, b.sourceId);
  swap(a.targetId, b.targetId);
  swap(a.refName, b.refName);
}

HawkReferenceRemovalEvent::HawkReferenceRemovalEvent(const HawkReferenceRemovalEvent& other149) {
  vcsItem = other149.vcsItem;
  sourceId = other149.sourceId;
  targetId = other149.targetId;
  refName = other149.refName;
}
HawkReferenceRemovalEvent& HawkReferenceRemovalEvent::operator=(const HawkReferenceRemovalEvent& other150) {
  vcsItem = other150.vcsItem;
  sourceId = other150.sourceId;
  targetId = other150.targetId;
  refName = other150.refName;
  return *this;
}
void HawkReferenceRemovalEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkReferenceRemovalEvent(";
  out << "vcsItem=" << to_string(vcsItem);
  out << ", " << "sourceId=" << to_string(sourceId);
  out << ", " << "targetId=" << to_string(targetId);
  out << ", " << "refName=" << to_string(refName);
  out << ")";
}


InvalidModelSpec::~InvalidModelSpec() throw() {
}


void InvalidModelSpec::__set_spec(const ModelSpec& val) {
  this->spec = val;
}

void InvalidModelSpec::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t InvalidModelSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_spec = false;
  bool isset_reason = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec.read(iprot);
          isset_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          isset_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reason)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidModelSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidModelSpec");

  xfer += oprot->writeFieldBegin("spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidModelSpec &a, InvalidModelSpec &b) {
  using ::std::swap;
  swap(a.spec, b.spec);
  swap(a.reason, b.reason);
}

InvalidModelSpec::InvalidModelSpec(const InvalidModelSpec& other151) {
  spec = other151.spec;
  reason = other151.reason;
}
InvalidModelSpec& InvalidModelSpec::operator=(const InvalidModelSpec& other152) {
  spec = other152.spec;
  reason = other152.reason;
  return *this;
}
void InvalidModelSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidModelSpec(";
  out << "spec=" << to_string(spec);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}


ModelElementType::~ModelElementType() throw() {
}


void ModelElementType::__set_id(const std::string& val) {
  this->id = val;
}

void ModelElementType::__set_metamodelUri(const std::string& val) {
  this->metamodelUri = val;
}

void ModelElementType::__set_typeName(const std::string& val) {
  this->typeName = val;
}

void ModelElementType::__set_attributes(const std::vector<SlotMetadata> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void ModelElementType::__set_references(const std::vector<SlotMetadata> & val) {
  this->references = val;
__isset.references = true;
}

uint32_t ModelElementType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_metamodelUri = false;
  bool isset_typeName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelUri);
          isset_metamodelUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          isset_typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributes.clear();
            uint32_t _size153;
            ::apache::thrift::protocol::TType _etype156;
            xfer += iprot->readListBegin(_etype156, _size153);
            this->attributes.resize(_size153);
            uint32_t _i157;
            for (_i157 = 0; _i157 < _size153; ++_i157)
            {
              xfer += this->attributes[_i157].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->references.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->references.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              xfer += this->references[_i162].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.references = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metamodelUri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ModelElementType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelElementType");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metamodelUri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->metamodelUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->typeName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
      std::vector<SlotMetadata> ::const_iterator _iter163;
      for (_iter163 = this->attributes.begin(); _iter163 != this->attributes.end(); ++_iter163)
      {
        xfer += (*_iter163).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.references) {
    xfer += oprot->writeFieldBegin("references", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->references.size()));
      std::vector<SlotMetadata> ::const_iterator _iter164;
      for (_iter164 = this->references.begin(); _iter164 != this->references.end(); ++_iter164)
      {
        xfer += (*_iter164).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelElementType &a, ModelElementType &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.metamodelUri, b.metamodelUri);
  swap(a.typeName, b.typeName);
  swap(a.attributes, b.attributes);
  swap(a.references, b.references);
  swap(a.__isset, b.__isset);
}

ModelElementType::ModelElementType(const ModelElementType& other165) {
  id = other165.id;
  metamodelUri = other165.metamodelUri;
  typeName = other165.typeName;
  attributes = other165.attributes;
  references = other165.references;
  __isset = other165.__isset;
}
ModelElementType& ModelElementType::operator=(const ModelElementType& other166) {
  id = other166.id;
  metamodelUri = other166.metamodelUri;
  typeName = other166.typeName;
  attributes = other166.attributes;
  references = other166.references;
  __isset = other166.__isset;
  return *this;
}
void ModelElementType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelElementType(";
  out << "id=" << to_string(id);
  out << ", " << "metamodelUri=" << to_string(metamodelUri);
  out << ", " << "typeName=" << to_string(typeName);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "references="; (__isset.references ? (out << to_string(references)) : (out << "<null>"));
  out << ")";
}


ReferenceSlot::~ReferenceSlot() throw() {
}


void ReferenceSlot::__set_name(const std::string& val) {
  this->name = val;
}

void ReferenceSlot::__set_position(const int32_t val) {
  this->position = val;
__isset.position = true;
}

void ReferenceSlot::__set_positions(const std::vector<int32_t> & val) {
  this->positions = val;
__isset.positions = true;
}

void ReferenceSlot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void ReferenceSlot::__set_ids(const std::vector<std::string> & val) {
  this->ids = val;
__isset.ids = true;
}

void ReferenceSlot::__set_mixed(const std::vector<MixedReference> & val) {
  this->mixed = val;
__isset.mixed = true;
}

uint32_t ReferenceSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->positions.clear();
            uint32_t _size167;
            ::apache::thrift::protocol::TType _etype170;
            xfer += iprot->readListBegin(_etype170, _size167);
            this->positions.resize(_size167);
            uint32_t _i171;
            for (_i171 = 0; _i171 < _size167; ++_i171)
            {
              xfer += iprot->readI32(this->positions[_i171]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.positions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->ids.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              xfer += iprot->readString(this->ids[_i176]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mixed.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->mixed.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->mixed[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mixed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReferenceSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReferenceSlot");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.position) {
    xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->position);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.positions) {
    xfer += oprot->writeFieldBegin("positions", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->positions.size()));
      std::vector<int32_t> ::const_iterator _iter182;
      for (_iter182 = this->positions.begin(); _iter182 != this->positions.end(); ++_iter182)
      {
        xfer += oprot->writeI32((*_iter182));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ids) {
    xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ids.size()));
      std::vector<std::string> ::const_iterator _iter183;
      for (_iter183 = this->ids.begin(); _iter183 != this->ids.end(); ++_iter183)
      {
        xfer += oprot->writeString((*_iter183));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mixed) {
    xfer += oprot->writeFieldBegin("mixed", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mixed.size()));
      std::vector<MixedReference> ::const_iterator _iter184;
      for (_iter184 = this->mixed.begin(); _iter184 != this->mixed.end(); ++_iter184)
      {
        xfer += (*_iter184).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReferenceSlot &a, ReferenceSlot &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.position, b.position);
  swap(a.positions, b.positions);
  swap(a.id, b.id);
  swap(a.ids, b.ids);
  swap(a.mixed, b.mixed);
  swap(a.__isset, b.__isset);
}

ReferenceSlot::ReferenceSlot(const ReferenceSlot& other185) {
  name = other185.name;
  position = other185.position;
  positions = other185.positions;
  id = other185.id;
  ids = other185.ids;
  mixed = other185.mixed;
  __isset = other185.__isset;
}
ReferenceSlot& ReferenceSlot::operator=(const ReferenceSlot& other186) {
  name = other186.name;
  position = other186.position;
  positions = other186.positions;
  id = other186.id;
  ids = other186.ids;
  mixed = other186.mixed;
  __isset = other186.__isset;
  return *this;
}
void ReferenceSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReferenceSlot(";
  out << "name=" << to_string(name);
  out << ", " << "position="; (__isset.position ? (out << to_string(position)) : (out << "<null>"));
  out << ", " << "positions="; (__isset.positions ? (out << to_string(positions)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "ids="; (__isset.ids ? (out << to_string(ids)) : (out << "<null>"));
  out << ", " << "mixed="; (__isset.mixed ? (out << to_string(mixed)) : (out << "<null>"));
  out << ")";
}


HawkChangeEvent::~HawkChangeEvent() throw() {
}


void HawkChangeEvent::__set_modelElementAddition(const HawkModelElementAdditionEvent& val) {
  this->modelElementAddition = val;
__isset.modelElementAddition = true;
}

void HawkChangeEvent::__set_modelElementRemoval(const HawkModelElementRemovalEvent& val) {
  this->modelElementRemoval = val;
__isset.modelElementRemoval = true;
}

void HawkChangeEvent::__set_modelElementAttributeUpdate(const HawkAttributeUpdateEvent& val) {
  this->modelElementAttributeUpdate = val;
__isset.modelElementAttributeUpdate = true;
}

void HawkChangeEvent::__set_modelElementAttributeRemoval(const HawkAttributeRemovalEvent& val) {
  this->modelElementAttributeRemoval = val;
__isset.modelElementAttributeRemoval = true;
}

void HawkChangeEvent::__set_referenceAddition(const HawkReferenceAdditionEvent& val) {
  this->referenceAddition = val;
__isset.referenceAddition = true;
}

void HawkChangeEvent::__set_referenceRemoval(const HawkReferenceRemovalEvent& val) {
  this->referenceRemoval = val;
__isset.referenceRemoval = true;
}

void HawkChangeEvent::__set_syncStart(const HawkSynchronizationStartEvent& val) {
  this->syncStart = val;
__isset.syncStart = true;
}

void HawkChangeEvent::__set_syncEnd(const HawkSynchronizationEndEvent& val) {
  this->syncEnd = val;
__isset.syncEnd = true;
}

void HawkChangeEvent::__set_fileAddition(const HawkFileAdditionEvent& val) {
  this->fileAddition = val;
__isset.fileAddition = true;
}

void HawkChangeEvent::__set_fileRemoval(const HawkFileRemovalEvent& val) {
  this->fileRemoval = val;
__isset.fileRemoval = true;
}

uint32_t HawkChangeEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelElementAddition.read(iprot);
          this->__isset.modelElementAddition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelElementRemoval.read(iprot);
          this->__isset.modelElementRemoval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelElementAttributeUpdate.read(iprot);
          this->__isset.modelElementAttributeUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelElementAttributeRemoval.read(iprot);
          this->__isset.modelElementAttributeRemoval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->referenceAddition.read(iprot);
          this->__isset.referenceAddition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->referenceRemoval.read(iprot);
          this->__isset.referenceRemoval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->syncStart.read(iprot);
          this->__isset.syncStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->syncEnd.read(iprot);
          this->__isset.syncEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileAddition.read(iprot);
          this->__isset.fileAddition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileRemoval.read(iprot);
          this->__isset.fileRemoval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HawkChangeEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkChangeEvent");

  if (this->__isset.modelElementAddition) {
    xfer += oprot->writeFieldBegin("modelElementAddition", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->modelElementAddition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.modelElementRemoval) {
    xfer += oprot->writeFieldBegin("modelElementRemoval", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->modelElementRemoval.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.modelElementAttributeUpdate) {
    xfer += oprot->writeFieldBegin("modelElementAttributeUpdate", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->modelElementAttributeUpdate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.modelElementAttributeRemoval) {
    xfer += oprot->writeFieldBegin("modelElementAttributeRemoval", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->modelElementAttributeRemoval.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.referenceAddition) {
    xfer += oprot->writeFieldBegin("referenceAddition", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->referenceAddition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.referenceRemoval) {
    xfer += oprot->writeFieldBegin("referenceRemoval", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->referenceRemoval.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.syncStart) {
    xfer += oprot->writeFieldBegin("syncStart", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->syncStart.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.syncEnd) {
    xfer += oprot->writeFieldBegin("syncEnd", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->syncEnd.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileAddition) {
    xfer += oprot->writeFieldBegin("fileAddition", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->fileAddition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileRemoval) {
    xfer += oprot->writeFieldBegin("fileRemoval", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->fileRemoval.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkChangeEvent &a, HawkChangeEvent &b) {
  using ::std::swap;
  swap(a.modelElementAddition, b.modelElementAddition);
  swap(a.modelElementRemoval, b.modelElementRemoval);
  swap(a.modelElementAttributeUpdate, b.modelElementAttributeUpdate);
  swap(a.modelElementAttributeRemoval, b.modelElementAttributeRemoval);
  swap(a.referenceAddition, b.referenceAddition);
  swap(a.referenceRemoval, b.referenceRemoval);
  swap(a.syncStart, b.syncStart);
  swap(a.syncEnd, b.syncEnd);
  swap(a.fileAddition, b.fileAddition);
  swap(a.fileRemoval, b.fileRemoval);
  swap(a.__isset, b.__isset);
}

HawkChangeEvent::HawkChangeEvent(const HawkChangeEvent& other187) {
  modelElementAddition = other187.modelElementAddition;
  modelElementRemoval = other187.modelElementRemoval;
  modelElementAttributeUpdate = other187.modelElementAttributeUpdate;
  modelElementAttributeRemoval = other187.modelElementAttributeRemoval;
  referenceAddition = other187.referenceAddition;
  referenceRemoval = other187.referenceRemoval;
  syncStart = other187.syncStart;
  syncEnd = other187.syncEnd;
  fileAddition = other187.fileAddition;
  fileRemoval = other187.fileRemoval;
  __isset = other187.__isset;
}
HawkChangeEvent& HawkChangeEvent::operator=(const HawkChangeEvent& other188) {
  modelElementAddition = other188.modelElementAddition;
  modelElementRemoval = other188.modelElementRemoval;
  modelElementAttributeUpdate = other188.modelElementAttributeUpdate;
  modelElementAttributeRemoval = other188.modelElementAttributeRemoval;
  referenceAddition = other188.referenceAddition;
  referenceRemoval = other188.referenceRemoval;
  syncStart = other188.syncStart;
  syncEnd = other188.syncEnd;
  fileAddition = other188.fileAddition;
  fileRemoval = other188.fileRemoval;
  __isset = other188.__isset;
  return *this;
}
void HawkChangeEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkChangeEvent(";
  out << "modelElementAddition="; (__isset.modelElementAddition ? (out << to_string(modelElementAddition)) : (out << "<null>"));
  out << ", " << "modelElementRemoval="; (__isset.modelElementRemoval ? (out << to_string(modelElementRemoval)) : (out << "<null>"));
  out << ", " << "modelElementAttributeUpdate="; (__isset.modelElementAttributeUpdate ? (out << to_string(modelElementAttributeUpdate)) : (out << "<null>"));
  out << ", " << "modelElementAttributeRemoval="; (__isset.modelElementAttributeRemoval ? (out << to_string(modelElementAttributeRemoval)) : (out << "<null>"));
  out << ", " << "referenceAddition="; (__isset.referenceAddition ? (out << to_string(referenceAddition)) : (out << "<null>"));
  out << ", " << "referenceRemoval="; (__isset.referenceRemoval ? (out << to_string(referenceRemoval)) : (out << "<null>"));
  out << ", " << "syncStart="; (__isset.syncStart ? (out << to_string(syncStart)) : (out << "<null>"));
  out << ", " << "syncEnd="; (__isset.syncEnd ? (out << to_string(syncEnd)) : (out << "<null>"));
  out << ", " << "fileAddition="; (__isset.fileAddition ? (out << to_string(fileAddition)) : (out << "<null>"));
  out << ", " << "fileRemoval="; (__isset.fileRemoval ? (out << to_string(fileRemoval)) : (out << "<null>"));
  out << ")";
}


HawkQueryOptions::~HawkQueryOptions() throw() {
}


void HawkQueryOptions::__set_repositoryPattern(const std::string& val) {
  this->repositoryPattern = val;
__isset.repositoryPattern = true;
}

void HawkQueryOptions::__set_filePatterns(const std::vector<std::string> & val) {
  this->filePatterns = val;
__isset.filePatterns = true;
}

void HawkQueryOptions::__set_defaultNamespaces(const std::string& val) {
  this->defaultNamespaces = val;
__isset.defaultNamespaces = true;
}

void HawkQueryOptions::__set_includeAttributes(const bool val) {
  this->includeAttributes = val;
__isset.includeAttributes = true;
}

void HawkQueryOptions::__set_includeReferences(const bool val) {
  this->includeReferences = val;
__isset.includeReferences = true;
}

void HawkQueryOptions::__set_includeNodeIDs(const bool val) {
  this->includeNodeIDs = val;
__isset.includeNodeIDs = true;
}

void HawkQueryOptions::__set_includeContained(const bool val) {
  this->includeContained = val;
__isset.includeContained = true;
}

void HawkQueryOptions::__set_effectiveMetamodelIncludes(const std::map<std::string, std::map<std::string, std::set<std::string> > > & val) {
  this->effectiveMetamodelIncludes = val;
__isset.effectiveMetamodelIncludes = true;
}

void HawkQueryOptions::__set_effectiveMetamodelExcludes(const std::map<std::string, std::map<std::string, std::set<std::string> > > & val) {
  this->effectiveMetamodelExcludes = val;
__isset.effectiveMetamodelExcludes = true;
}

void HawkQueryOptions::__set_includeDerived(const bool val) {
  this->includeDerived = val;
__isset.includeDerived = true;
}

uint32_t HawkQueryOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repositoryPattern);
          this->__isset.repositoryPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filePatterns.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->filePatterns.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += iprot->readString(this->filePatterns[_i193]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filePatterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultNamespaces);
          this->__isset.defaultNamespaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeAttributes);
          this->__isset.includeAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeReferences);
          this->__isset.includeReferences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeNodeIDs);
          this->__isset.includeNodeIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeContained);
          this->__isset.includeContained = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->effectiveMetamodelIncludes.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _ktype195;
            ::apache::thrift::protocol::TType _vtype196;
            xfer += iprot->readMapBegin(_ktype195, _vtype196, _size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              std::string _key199;
              xfer += iprot->readString(_key199);
              std::map<std::string, std::set<std::string> > & _val200 = this->effectiveMetamodelIncludes[_key199];
              {
                _val200.clear();
                uint32_t _size201;
                ::apache::thrift::protocol::TType _ktype202;
                ::apache::thrift::protocol::TType _vtype203;
                xfer += iprot->readMapBegin(_ktype202, _vtype203, _size201);
                uint32_t _i205;
                for (_i205 = 0; _i205 < _size201; ++_i205)
                {
                  std::string _key206;
                  xfer += iprot->readString(_key206);
                  std::set<std::string> & _val207 = _val200[_key206];
                  {
                    _val207.clear();
                    uint32_t _size208;
                    ::apache::thrift::protocol::TType _etype211;
                    xfer += iprot->readSetBegin(_etype211, _size208);
                    uint32_t _i212;
                    for (_i212 = 0; _i212 < _size208; ++_i212)
                    {
                      std::string _elem213;
                      xfer += iprot->readString(_elem213);
                      _val207.insert(_elem213);
                    }
                    xfer += iprot->readSetEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.effectiveMetamodelIncludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->effectiveMetamodelExcludes.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _ktype215;
            ::apache::thrift::protocol::TType _vtype216;
            xfer += iprot->readMapBegin(_ktype215, _vtype216, _size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              std::string _key219;
              xfer += iprot->readString(_key219);
              std::map<std::string, std::set<std::string> > & _val220 = this->effectiveMetamodelExcludes[_key219];
              {
                _val220.clear();
                uint32_t _size221;
                ::apache::thrift::protocol::TType _ktype222;
                ::apache::thrift::protocol::TType _vtype223;
                xfer += iprot->readMapBegin(_ktype222, _vtype223, _size221);
                uint32_t _i225;
                for (_i225 = 0; _i225 < _size221; ++_i225)
                {
                  std::string _key226;
                  xfer += iprot->readString(_key226);
                  std::set<std::string> & _val227 = _val220[_key226];
                  {
                    _val227.clear();
                    uint32_t _size228;
                    ::apache::thrift::protocol::TType _etype231;
                    xfer += iprot->readSetBegin(_etype231, _size228);
                    uint32_t _i232;
                    for (_i232 = 0; _i232 < _size228; ++_i232)
                    {
                      std::string _elem233;
                      xfer += iprot->readString(_elem233);
                      _val227.insert(_elem233);
                    }
                    xfer += iprot->readSetEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.effectiveMetamodelExcludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeDerived);
          this->__isset.includeDerived = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HawkQueryOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HawkQueryOptions");

  if (this->__isset.repositoryPattern) {
    xfer += oprot->writeFieldBegin("repositoryPattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->repositoryPattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filePatterns) {
    xfer += oprot->writeFieldBegin("filePatterns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filePatterns.size()));
      std::vector<std::string> ::const_iterator _iter234;
      for (_iter234 = this->filePatterns.begin(); _iter234 != this->filePatterns.end(); ++_iter234)
      {
        xfer += oprot->writeString((*_iter234));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultNamespaces) {
    xfer += oprot->writeFieldBegin("defaultNamespaces", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->defaultNamespaces);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeAttributes) {
    xfer += oprot->writeFieldBegin("includeAttributes", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->includeAttributes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeReferences) {
    xfer += oprot->writeFieldBegin("includeReferences", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->includeReferences);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeNodeIDs) {
    xfer += oprot->writeFieldBegin("includeNodeIDs", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->includeNodeIDs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeContained) {
    xfer += oprot->writeFieldBegin("includeContained", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->includeContained);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.effectiveMetamodelIncludes) {
    xfer += oprot->writeFieldBegin("effectiveMetamodelIncludes", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->effectiveMetamodelIncludes.size()));
      std::map<std::string, std::map<std::string, std::set<std::string> > > ::const_iterator _iter235;
      for (_iter235 = this->effectiveMetamodelIncludes.begin(); _iter235 != this->effectiveMetamodelIncludes.end(); ++_iter235)
      {
        xfer += oprot->writeString(_iter235->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(_iter235->second.size()));
          std::map<std::string, std::set<std::string> > ::const_iterator _iter236;
          for (_iter236 = _iter235->second.begin(); _iter236 != _iter235->second.end(); ++_iter236)
          {
            xfer += oprot->writeString(_iter236->first);
            {
              xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter236->second.size()));
              std::set<std::string> ::const_iterator _iter237;
              for (_iter237 = _iter236->second.begin(); _iter237 != _iter236->second.end(); ++_iter237)
              {
                xfer += oprot->writeString((*_iter237));
              }
              xfer += oprot->writeSetEnd();
            }
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.effectiveMetamodelExcludes) {
    xfer += oprot->writeFieldBegin("effectiveMetamodelExcludes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->effectiveMetamodelExcludes.size()));
      std::map<std::string, std::map<std::string, std::set<std::string> > > ::const_iterator _iter238;
      for (_iter238 = this->effectiveMetamodelExcludes.begin(); _iter238 != this->effectiveMetamodelExcludes.end(); ++_iter238)
      {
        xfer += oprot->writeString(_iter238->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(_iter238->second.size()));
          std::map<std::string, std::set<std::string> > ::const_iterator _iter239;
          for (_iter239 = _iter238->second.begin(); _iter239 != _iter238->second.end(); ++_iter239)
          {
            xfer += oprot->writeString(_iter239->first);
            {
              xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter239->second.size()));
              std::set<std::string> ::const_iterator _iter240;
              for (_iter240 = _iter239->second.begin(); _iter240 != _iter239->second.end(); ++_iter240)
              {
                xfer += oprot->writeString((*_iter240));
              }
              xfer += oprot->writeSetEnd();
            }
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeDerived) {
    xfer += oprot->writeFieldBegin("includeDerived", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->includeDerived);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HawkQueryOptions &a, HawkQueryOptions &b) {
  using ::std::swap;
  swap(a.repositoryPattern, b.repositoryPattern);
  swap(a.filePatterns, b.filePatterns);
  swap(a.defaultNamespaces, b.defaultNamespaces);
  swap(a.includeAttributes, b.includeAttributes);
  swap(a.includeReferences, b.includeReferences);
  swap(a.includeNodeIDs, b.includeNodeIDs);
  swap(a.includeContained, b.includeContained);
  swap(a.effectiveMetamodelIncludes, b.effectiveMetamodelIncludes);
  swap(a.effectiveMetamodelExcludes, b.effectiveMetamodelExcludes);
  swap(a.includeDerived, b.includeDerived);
  swap(a.__isset, b.__isset);
}

HawkQueryOptions::HawkQueryOptions(const HawkQueryOptions& other241) {
  repositoryPattern = other241.repositoryPattern;
  filePatterns = other241.filePatterns;
  defaultNamespaces = other241.defaultNamespaces;
  includeAttributes = other241.includeAttributes;
  includeReferences = other241.includeReferences;
  includeNodeIDs = other241.includeNodeIDs;
  includeContained = other241.includeContained;
  effectiveMetamodelIncludes = other241.effectiveMetamodelIncludes;
  effectiveMetamodelExcludes = other241.effectiveMetamodelExcludes;
  includeDerived = other241.includeDerived;
  __isset = other241.__isset;
}
HawkQueryOptions& HawkQueryOptions::operator=(const HawkQueryOptions& other242) {
  repositoryPattern = other242.repositoryPattern;
  filePatterns = other242.filePatterns;
  defaultNamespaces = other242.defaultNamespaces;
  includeAttributes = other242.includeAttributes;
  includeReferences = other242.includeReferences;
  includeNodeIDs = other242.includeNodeIDs;
  includeContained = other242.includeContained;
  effectiveMetamodelIncludes = other242.effectiveMetamodelIncludes;
  effectiveMetamodelExcludes = other242.effectiveMetamodelExcludes;
  includeDerived = other242.includeDerived;
  __isset = other242.__isset;
  return *this;
}
void HawkQueryOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HawkQueryOptions(";
  out << "repositoryPattern="; (__isset.repositoryPattern ? (out << to_string(repositoryPattern)) : (out << "<null>"));
  out << ", " << "filePatterns="; (__isset.filePatterns ? (out << to_string(filePatterns)) : (out << "<null>"));
  out << ", " << "defaultNamespaces="; (__isset.defaultNamespaces ? (out << to_string(defaultNamespaces)) : (out << "<null>"));
  out << ", " << "includeAttributes="; (__isset.includeAttributes ? (out << to_string(includeAttributes)) : (out << "<null>"));
  out << ", " << "includeReferences="; (__isset.includeReferences ? (out << to_string(includeReferences)) : (out << "<null>"));
  out << ", " << "includeNodeIDs="; (__isset.includeNodeIDs ? (out << to_string(includeNodeIDs)) : (out << "<null>"));
  out << ", " << "includeContained="; (__isset.includeContained ? (out << to_string(includeContained)) : (out << "<null>"));
  out << ", " << "effectiveMetamodelIncludes="; (__isset.effectiveMetamodelIncludes ? (out << to_string(effectiveMetamodelIncludes)) : (out << "<null>"));
  out << ", " << "effectiveMetamodelExcludes="; (__isset.effectiveMetamodelExcludes ? (out << to_string(effectiveMetamodelExcludes)) : (out << "<null>"));
  out << ", " << "includeDerived="; (__isset.includeDerived ? (out << to_string(includeDerived)) : (out << "<null>"));
  out << ")";
}


ModelElement::~ModelElement() throw() {
}


void ModelElement::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void ModelElement::__set_repositoryURL(const std::string& val) {
  this->repositoryURL = val;
__isset.repositoryURL = true;
}

void ModelElement::__set_file(const std::string& val) {
  this->file = val;
__isset.file = true;
}

void ModelElement::__set_metamodelUri(const std::string& val) {
  this->metamodelUri = val;
__isset.metamodelUri = true;
}

void ModelElement::__set_typeName(const std::string& val) {
  this->typeName = val;
__isset.typeName = true;
}

void ModelElement::__set_attributes(const std::vector<AttributeSlot> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void ModelElement::__set_references(const std::vector<ReferenceSlot> & val) {
  this->references = val;
__isset.references = true;
}

void ModelElement::__set_containers(const std::vector<ContainerSlot> & val) {
  this->containers = val;
__isset.containers = true;
}

uint32_t ModelElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->repositoryURL);
          this->__isset.repositoryURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file);
          this->__isset.file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metamodelUri);
          this->__isset.metamodelUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typeName);
          this->__isset.typeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributes.clear();
            uint32_t _size243;
            ::apache::thrift::protocol::TType _etype246;
            xfer += iprot->readListBegin(_etype246, _size243);
            this->attributes.resize(_size243);
            uint32_t _i247;
            for (_i247 = 0; _i247 < _size243; ++_i247)
            {
              xfer += this->attributes[_i247].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->references.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->references.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += this->references[_i252].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.references = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->containers.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->containers.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += this->containers[_i257].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.containers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelElement");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.repositoryURL) {
    xfer += oprot->writeFieldBegin("repositoryURL", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->repositoryURL);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file) {
    xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metamodelUri) {
    xfer += oprot->writeFieldBegin("metamodelUri", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->metamodelUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.typeName) {
    xfer += oprot->writeFieldBegin("typeName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->typeName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
      std::vector<AttributeSlot> ::const_iterator _iter258;
      for (_iter258 = this->attributes.begin(); _iter258 != this->attributes.end(); ++_iter258)
      {
        xfer += (*_iter258).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.references) {
    xfer += oprot->writeFieldBegin("references", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->references.size()));
      std::vector<ReferenceSlot> ::const_iterator _iter259;
      for (_iter259 = this->references.begin(); _iter259 != this->references.end(); ++_iter259)
      {
        xfer += (*_iter259).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.containers) {
    xfer += oprot->writeFieldBegin("containers", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->containers.size()));
      std::vector<ContainerSlot> ::const_iterator _iter260;
      for (_iter260 = this->containers.begin(); _iter260 != this->containers.end(); ++_iter260)
      {
        xfer += (*_iter260).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelElement &a, ModelElement &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.repositoryURL, b.repositoryURL);
  swap(a.file, b.file);
  swap(a.metamodelUri, b.metamodelUri);
  swap(a.typeName, b.typeName);
  swap(a.attributes, b.attributes);
  swap(a.references, b.references);
  swap(a.containers, b.containers);
  swap(a.__isset, b.__isset);
}

ModelElement::ModelElement(const ModelElement& other261) {
  id = other261.id;
  repositoryURL = other261.repositoryURL;
  file = other261.file;
  metamodelUri = other261.metamodelUri;
  typeName = other261.typeName;
  attributes = other261.attributes;
  references = other261.references;
  containers = other261.containers;
  __isset = other261.__isset;
}
ModelElement& ModelElement::operator=(const ModelElement& other262) {
  id = other262.id;
  repositoryURL = other262.repositoryURL;
  file = other262.file;
  metamodelUri = other262.metamodelUri;
  typeName = other262.typeName;
  attributes = other262.attributes;
  references = other262.references;
  containers = other262.containers;
  __isset = other262.__isset;
  return *this;
}
void ModelElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelElement(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "repositoryURL="; (__isset.repositoryURL ? (out << to_string(repositoryURL)) : (out << "<null>"));
  out << ", " << "file="; (__isset.file ? (out << to_string(file)) : (out << "<null>"));
  out << ", " << "metamodelUri="; (__isset.metamodelUri ? (out << to_string(metamodelUri)) : (out << "<null>"));
  out << ", " << "typeName="; (__isset.typeName ? (out << to_string(typeName)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "references="; (__isset.references ? (out << to_string(references)) : (out << "<null>"));
  out << ", " << "containers="; (__isset.containers ? (out << to_string(containers)) : (out << "<null>"));
  out << ")";
}


ContainerSlot::~ContainerSlot() throw() {
}


void ContainerSlot::__set_name(const std::string& val) {
  this->name = val;
}

void ContainerSlot::__set_elements(const std::vector<ModelElement> & val) {
  this->elements = val;
}

uint32_t ContainerSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_elements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size263;
            ::apache::thrift::protocol::TType _etype266;
            xfer += iprot->readListBegin(_etype266, _size263);
            this->elements.resize(_size263);
            uint32_t _i267;
            for (_i267 = 0; _i267 < _size263; ++_i267)
            {
              xfer += this->elements[_i267].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_elements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ContainerSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ContainerSlot");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
    std::vector<ModelElement> ::const_iterator _iter268;
    for (_iter268 = this->elements.begin(); _iter268 != this->elements.end(); ++_iter268)
    {
      xfer += (*_iter268).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContainerSlot &a, ContainerSlot &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.elements, b.elements);
}

ContainerSlot::ContainerSlot(const ContainerSlot& other269) {
  name = other269.name;
  elements = other269.elements;
}
ContainerSlot& ContainerSlot::operator=(const ContainerSlot& other270) {
  name = other270.name;
  elements = other270.elements;
  return *this;
}
void ContainerSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ContainerSlot(";
  out << "name=" << to_string(name);
  out << ", " << "elements=" << to_string(elements);
  out << ")";
}


QueryResult::~QueryResult() throw() {
}


void QueryResult::__set_vBoolean(const bool val) {
  this->vBoolean = val;
__isset.vBoolean = true;
}

void QueryResult::__set_vByte(const int8_t val) {
  this->vByte = val;
__isset.vByte = true;
}

void QueryResult::__set_vShort(const int16_t val) {
  this->vShort = val;
__isset.vShort = true;
}

void QueryResult::__set_vInteger(const int32_t val) {
  this->vInteger = val;
__isset.vInteger = true;
}

void QueryResult::__set_vLong(const int64_t val) {
  this->vLong = val;
__isset.vLong = true;
}

void QueryResult::__set_vDouble(const double val) {
  this->vDouble = val;
__isset.vDouble = true;
}

void QueryResult::__set_vString(const std::string& val) {
  this->vString = val;
__isset.vString = true;
}

void QueryResult::__set_vModelElement(const ModelElement& val) {
  this->vModelElement = val;
__isset.vModelElement = true;
}

void QueryResult::__set_vModelElementType(const ModelElementType& val) {
  this->vModelElementType = val;
__isset.vModelElementType = true;
}

void QueryResult::__set_vMap(const std::map<std::string, QueryResult> & val) {
  this->vMap = val;
__isset.vMap = true;
}

void QueryResult::__set_vList(const std::vector<QueryResult> & val) {
  this->vList = val;
__isset.vList = true;
}

uint32_t QueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->vBoolean);
          this->__isset.vBoolean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->vByte);
          this->__isset.vByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->vShort);
          this->__isset.vShort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vInteger);
          this->__isset.vInteger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vLong);
          this->__isset.vLong = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vDouble);
          this->__isset.vDouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vString);
          this->__isset.vString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vModelElement.read(iprot);
          this->__isset.vModelElement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vModelElementType.read(iprot);
          this->__isset.vModelElementType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vMap.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _ktype272;
            ::apache::thrift::protocol::TType _vtype273;
            xfer += iprot->readMapBegin(_ktype272, _vtype273, _size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              std::string _key276;
              xfer += iprot->readString(_key276);
              QueryResult& _val277 = this->vMap[_key276];
              xfer += _val277.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vList.clear();
            uint32_t _size278;
            ::apache::thrift::protocol::TType _etype281;
            xfer += iprot->readListBegin(_etype281, _size278);
            this->vList.resize(_size278);
            uint32_t _i282;
            for (_i282 = 0; _i282 < _size278; ++_i282)
            {
              xfer += this->vList[_i282].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryResult");

  if (this->__isset.vBoolean) {
    xfer += oprot->writeFieldBegin("vBoolean", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->vBoolean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vByte) {
    xfer += oprot->writeFieldBegin("vByte", ::apache::thrift::protocol::T_BYTE, 2);
    xfer += oprot->writeByte(this->vByte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vShort) {
    xfer += oprot->writeFieldBegin("vShort", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->vShort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vInteger) {
    xfer += oprot->writeFieldBegin("vInteger", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->vInteger);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vLong) {
    xfer += oprot->writeFieldBegin("vLong", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->vLong);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vDouble) {
    xfer += oprot->writeFieldBegin("vDouble", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->vDouble);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vString) {
    xfer += oprot->writeFieldBegin("vString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->vString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vModelElement) {
    xfer += oprot->writeFieldBegin("vModelElement", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->vModelElement.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vModelElementType) {
    xfer += oprot->writeFieldBegin("vModelElementType", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->vModelElementType.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vMap) {
    xfer += oprot->writeFieldBegin("vMap", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vMap.size()));
      std::map<std::string, QueryResult> ::const_iterator _iter283;
      for (_iter283 = this->vMap.begin(); _iter283 != this->vMap.end(); ++_iter283)
      {
        xfer += oprot->writeString(_iter283->first);
        xfer += _iter283->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vList) {
    xfer += oprot->writeFieldBegin("vList", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vList.size()));
      std::vector<QueryResult> ::const_iterator _iter284;
      for (_iter284 = this->vList.begin(); _iter284 != this->vList.end(); ++_iter284)
      {
        xfer += (*_iter284).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryResult &a, QueryResult &b) {
  using ::std::swap;
  swap(a.vBoolean, b.vBoolean);
  swap(a.vByte, b.vByte);
  swap(a.vShort, b.vShort);
  swap(a.vInteger, b.vInteger);
  swap(a.vLong, b.vLong);
  swap(a.vDouble, b.vDouble);
  swap(a.vString, b.vString);
  swap(a.vModelElement, b.vModelElement);
  swap(a.vModelElementType, b.vModelElementType);
  swap(a.vMap, b.vMap);
  swap(a.vList, b.vList);
  swap(a.__isset, b.__isset);
}

QueryResult::QueryResult(const QueryResult& other285) {
  vBoolean = other285.vBoolean;
  vByte = other285.vByte;
  vShort = other285.vShort;
  vInteger = other285.vInteger;
  vLong = other285.vLong;
  vDouble = other285.vDouble;
  vString = other285.vString;
  vModelElement = other285.vModelElement;
  vModelElementType = other285.vModelElementType;
  vMap = other285.vMap;
  vList = other285.vList;
  __isset = other285.__isset;
}
QueryResult& QueryResult::operator=(const QueryResult& other286) {
  vBoolean = other286.vBoolean;
  vByte = other286.vByte;
  vShort = other286.vShort;
  vInteger = other286.vInteger;
  vLong = other286.vLong;
  vDouble = other286.vDouble;
  vString = other286.vString;
  vModelElement = other286.vModelElement;
  vModelElementType = other286.vModelElementType;
  vMap = other286.vMap;
  vList = other286.vList;
  __isset = other286.__isset;
  return *this;
}
void QueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryResult(";
  out << "vBoolean="; (__isset.vBoolean ? (out << to_string(vBoolean)) : (out << "<null>"));
  out << ", " << "vByte="; (__isset.vByte ? (out << to_string(vByte)) : (out << "<null>"));
  out << ", " << "vShort="; (__isset.vShort ? (out << to_string(vShort)) : (out << "<null>"));
  out << ", " << "vInteger="; (__isset.vInteger ? (out << to_string(vInteger)) : (out << "<null>"));
  out << ", " << "vLong="; (__isset.vLong ? (out << to_string(vLong)) : (out << "<null>"));
  out << ", " << "vDouble="; (__isset.vDouble ? (out << to_string(vDouble)) : (out << "<null>"));
  out << ", " << "vString="; (__isset.vString ? (out << to_string(vString)) : (out << "<null>"));
  out << ", " << "vModelElement="; (__isset.vModelElement ? (out << to_string(vModelElement)) : (out << "<null>"));
  out << ", " << "vModelElementType="; (__isset.vModelElementType ? (out << to_string(vModelElementType)) : (out << "<null>"));
  out << ", " << "vMap="; (__isset.vMap ? (out << to_string(vMap)) : (out << "<null>"));
  out << ", " << "vList="; (__isset.vList ? (out << to_string(vList)) : (out << "<null>"));
  out << ")";
}


QueryReport::~QueryReport() throw() {
}


void QueryReport::__set_result(const QueryResult& val) {
  this->result = val;
}

void QueryReport::__set_wallMillis(const int64_t val) {
  this->wallMillis = val;
}

void QueryReport::__set_isCancelled(const bool val) {
  this->isCancelled = val;
}

uint32_t QueryReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_wallMillis = false;
  bool isset_isCancelled = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->wallMillis);
          isset_wallMillis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isCancelled);
          isset_isCancelled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallMillis)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isCancelled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QueryReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryReport");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallMillis", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->wallMillis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isCancelled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isCancelled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryReport &a, QueryReport &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.wallMillis, b.wallMillis);
  swap(a.isCancelled, b.isCancelled);
}

QueryReport::QueryReport(const QueryReport& other287) {
  result = other287.result;
  wallMillis = other287.wallMillis;
  isCancelled = other287.isCancelled;
}
QueryReport& QueryReport::operator=(const QueryReport& other288) {
  result = other288.result;
  wallMillis = other288.wallMillis;
  isCancelled = other288.isCancelled;
  return *this;
}
void QueryReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryReport(";
  out << "result=" << to_string(result);
  out << ", " << "wallMillis=" << to_string(wallMillis);
  out << ", " << "isCancelled=" << to_string(isCancelled);
  out << ")";
}


